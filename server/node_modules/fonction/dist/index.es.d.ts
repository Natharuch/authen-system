/**
 * Placeholder to indicate that the argument is not explicitly set.
 *
 * @returns The results of `Symbol('_')`
 *
 * @public
 */
declare const _: unique symbol;//# sourceMappingURL=index.es.d.ts.map

// Copyright 2021-present the Curry authors. All rights reserved. MIT license.
// deno-lint-ignore-file no-explicit-any
/**
 * Alias for Any array types
 *
 * @internal
 */
type AnyArray = readonly unknown[];
/**
 * @internal
 */
type Union2Intersection<U> = (U extends unknown ? (arg: U) => void : never) extends (arg: infer I) => void ? I : never;
/**
 * Pop types
 * @typeParams - T Any array
 * @example
 * ```ts
 * Pop<[1, 2, 3]> = [1, 2].
 * ```
 *
 * @internal
 */
type Pop<T extends AnyArray> = T extends [
    ...infer Head,
    unknown
] ? Head : T extends readonly [
    ...infer Head,
    unknown
] ? readonly [
    ...Head
] : never;
/**
 * Shift types
 * @typeParams S - Any array
 * @example
 * ```ts
 * Shift<[1], [1, 2, 3]> = [2, 3].
 * Shift<[1, 2], [1, 2, 3]> = [3].
 * ```
 *
 * @internal
 */
type Shift<S extends AnyArray, T extends AnyArray> = T extends [
    ...S,
    ...infer Rest
] ? Rest : never;
/**
 * @example
 * ```ts
 * UnionFactorial<[1, 2, 3]> = [1] | [1, 2] | [1, 2, 3].
 * ```
 *
 * @internal
 */
type UnionFactorial<T extends AnyArray> = T extends readonly [
] ? never : T | UnionFactorial<Pop<T>>;
/**
 * @example
 * ```ts
 * OverloadsByArgs<[1] | [1, 2], [1, 2, 3], 7> =
 *  | CurriedWithFixArgs<[1], [2, 3], 7>
 *  | CurriedWithFixArgs<[1, 2], [3], 7>.
 * ```
 *
 * @internal
 */
type OverloadsByArgs<Args extends AnyArray, FullArgs extends AnyArray, ReturnValue> = Args extends unknown ? CurriedWithFixArgs<Args, Shift<Args, FullArgs>, ReturnValue> : never;
/**
 * @internal
 */
type CurriedWithFixArgs<Args extends AnyArray, RestArgs extends AnyArray, ReturnValue> = (...args: Args) => Curried<RestArgs, ReturnValue>;
/**
 * Curry types
 *
 * @internal
 */
type Curried<Args extends AnyArray, ReturnValue> = Args extends [
] ? ReturnValue : Union2Intersection<OverloadsByArgs<UnionFactorial<Args>, Args, ReturnValue>>;
/**
 * Creates a function that accepts arguments of `fn` and either invokes `fn` returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining `fn` arguments, and so on.
 *
 * @param fn - The function to curry
 * @returns The new curried function
 *
 * @remarks
 * Maximum number of arity is `19`. Beyond that, the type system will breaks.
 *
 * @example
 * ```ts
 * const replace = (from: string, to: string, val: string) => val.replace(from, to)
 * const curriedReplace = curry(replace)
 * const curriedReplace('hello', 'hi', 'hello world') // 'hi world'
 * const curriedReplace('hello')('hi', 'hello world') // 'hi world'
 * const curriedReplace('hello')('hi')('hello world') // 'hi world'
 * ```
 *
 * @beta
 */
declare const curry: <T extends unknown[], R>(fn: (...args: T) => R) => T["length"] extends 0 ? () => R : Curried<T, R>;
//# sourceMappingURL=index.es.d.ts.map

/**
 * Infer the head types.
 *
 * @typeParam T - `string` or any `array`
 * @returns Head element of the `T`
 *
 * @example
 * ```ts
 * // String
 * Head<string> // string
 * Head<''> // ''
 * Head<'hello'> // 'h'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * Head<[] | never[] | readonly [] | readonly never[]> // undefined
 * Head<['hello', 'world']> // 'hello'
 * Head<string | number[]> // string | number | undefined
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link Last}
 *
 * @public
 */
type Head<T extends readonly unknown[] | string> = T extends string ? T extends `${infer F}${string}` ? F : T extends "" ? "" : string : T extends readonly [
    infer U,
    ...infer _
] ? U : T[0] | undefined;
/**
 * Infer the head types.
 *
 * @typeParam T - `string` or any `array`
 * @returns Head element of the `T`
 *
 * @example
 * ```ts
 * // String
 * head<''> // ''
 * head<'hello'> // 'hello'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * head<[]> // undefined
 * head<['hello', 'world']> // 'hello'
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link Last}
 *
 * @public
 */
declare const head: <T extends string | readonly unknown[]>(val: T) => Head<T>;
/**
 * @example
 * ```ts
 * InitString<string> // string
 * InitString<''> // ''
 * InitString<'a'> // ''
 * InitString<'ab'> // 'a'
 * InitString<'abcd'> // 'abc'
 * ```
 * @internal
 */
type InitString<T extends string> = T extends `${infer F}${infer R}` ? R extends "" ? "" : `${F}${InitString<R>}` : T extends "" ? "" : string;
/**
 * Infer the init types.
 * @typeParam T - `string` or any `array`
 *
 * @example
 * ```ts
 * // String
 * Init<string> // string
 * Init<''> // ''
 * Init<'hello'> // 'hell'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * Init<[] | never[] | readonly [] | readonly never[]> // []
 * Init<['hello']> // []
 * Init<['hello', 'world']> // ['hello']
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link Tail}
 *
 * @public
 */
type Init<T extends string | readonly unknown[]> = T extends string ? InitString<T> : T extends readonly [
    ...infer I,
    unknown
] ? I : T;
/**
 * Returns all but the init element of the given list or string.
 * @param val - string or any array object
 * @returns The result of `val.slice(0, -1)`
 *
 * @remarks
 * The maximum number of characters for the type system to work properly is 16.
 *
 * @example
 * ```ts
 * // String
 * init('hello') // 'hell'
 * init('h') // ''
 * init('') // ''
 * ```
 *
 * @example
 * ```ts
 * init([1, 2, 3]) // [1, 2]
 * init(['hello', 'world']) // ['hello']
 * init(['hello']) // []
 * init([]) // []
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link tail}
 *
 * @public
 */
declare const init: <T extends string | readonly unknown[]>(val: T) => Init<T>;
/**
 * @example
 * ```ts
 * LastString<''> // ''
 * LastString<'a'> // 'a'
 * LastString<'abcdefghijk'> // 'k'
 * ```
 *
 * @internal
 */
type LastString<T extends string> = T extends `${infer L}${infer R}` ? R extends "" ? L : LastString<R> : T extends "" ? "" : string;
/**
 * Infer the last types.
 *
 * @typeParam T - `string` or any `array`
 *
 * @example
 * ```ts
 * // String
 * Last<string> // string
 * Last<''> // ''
 * Last<'hello'> // 'o'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * Last<[] | never[] | readonly [] | readonly never[]> // undefined
 * Last<['hello', 'world']> // 'world'
 * Last<string | number[]> // string | number | undefined
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link First}
 *
 * @public
 */
type Last<T extends string | readonly unknown[]> = T extends string ? LastString<T> : T extends readonly [
    ...infer _,
    infer L
] ? L : T[T["length"]] | undefined;
/**
 * Returns the last element of the given list or string.
 *
 * @param val - `string` or any `array` object
 * @returns The last element of the `val`
 *
 * @remarks
 * The maximum number of characters for the type system to work properly is 24.
 *
 * @example
 * ```ts
 * // String
 * last('') // ''
 * last('hello') // 'o'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * last('hello', 'new', 'world') // 'world'
 * last([]) // undefined
 * last(['one', 2, 3, 4]) // 4
 * ```
 *
 * @see Related to {@link first}
 *
 * @public
 */
declare const last: <T extends string | readonly unknown[]>(val: T) => Last<T>;
/**
 * Infer the tail types.
 * @typeParam T - `string` or any `array`
 *
 * @example
 * ```ts
 * // String
 * Tail<string> // string
 * Tail<''> // ''
 * Tail<'a'> // ''
 * Tail<'hello'> // 'ello'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * Tail<[] | never[] | readonly [] | readonly never[]> // []
 * Tail<['hello']> // []
 * Tail<['hello', 'world']> // ['world']
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link Init}
 *
 * @public
 */
type Tail<T extends string | readonly unknown[]> = T extends string ? T extends `${string}${infer R}` ? R : T extends "" ? "" : string : T extends readonly [
    unknown,
    ...infer R
] ? R : T;
/**
 * Returns all but the first element of the given list or string.
 *
 * @param val - string or any array object
 * @returns The result of `val.slice(1, Infinity)`
 *
 * @example
 * ```ts
 * // String
 * tail('hello') // 'ello'
 * tail('h') // ''
 * tail('') // ''
 * ```
 *
 * @example
 * ```ts
 * tail([1, 2, 3]) // [2, 3]
 * tail(['hello', 'world']) // ['world']
 * tail(['hello']) // []
 * tail([]) // []
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link head}
 *
 * @public
 */
declare const tail: <T extends string | readonly unknown[]>(val: T) => Tail<T>;
// re-export
/**
 * Adds first argument and second argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a + b`
 *
 * @example
 * ```ts
 * // Basic
 * add(1, 2) // 3
 * ```
 * @example
 * ```ts
 * // Bigint
 * add(1n, 2n) // 3n
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const plus2(2)
 * plus2(-3) // -1
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link subtract} {@link multiply} {@link divide}
 *
 * @public
 */
declare const add: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
};
// Copyright 2021-present the Fonction authors. All rights reserved. MIT license.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Type of any function.
 *
 * @public
 *
 * @typeParam T - Argument types
 */
type AnyFn<T = any, U = unknown> = (...args: T[]) => U;
/**
 * Type of arity 1 function.
 *
 * @public
 *
 * @typeParam T - Argument types
 */
type Arity1Fn<T = any, U = unknown> = (args: T) => U;
/**
 * Alias for Primitive values types.
 *
 * @category `Alias`
 *
 * @public
 *
 */
type Primitive = string | number | bigint | boolean | symbol | undefined | null;
/**
 * Abbreviation for Ordinal.
 *
 * @category `Alias`
 *
 * @public
 */
type Ord = string | number | bigint | boolean | Date;
/**
 * Alias for Empty values
 *
 * @category `Alias`
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/ban-types
type Empty = "" | [
] | {};
/**
 * Alias for Falsy values.
 *
 * @remarks
 * This is not a strict `Falsy`. TypeScript type system cannot define `NaN`.
 *
 * @category `Alias`
 *
 * @public
 */
type FalsyLike = false | "" | 0 | 0n | null | undefined;
/**
 * Alias for Space values.
 *
 * @category `Alias`
 *
 * @public
 */
type Space = " " | "\n" | "\t";
/**
 * Alias for TypedArray
 *
 * @beta
 */
type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;
/**
 * Returns return value if argument is `function`; otherwise returns the value as it is.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'function' ? val(): val`
 *
 * @example
 * ```ts
 * advance(1) // 1
 * advance(() => 1) // 1
 * ```
 *
 * @category `Logic`
 *
 * @public
 */
declare const advance: <T>(val: T | AnyFn<any, T>) => T;
/**
 * Returns `true` if both arguments are true; otherwise `false`.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!!a && !!bb` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 *
 * @example
 * ```ts
 * and(true, true) // true
 * and(false, true) // false
 * and(true, false) // false
 * and(false, false) // false
 * and(() => 1, () => 2) // true
 * and(() => 1, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link or} {@link xor}
 *
 * @public
 */
declare const and: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? false : U extends FalsyLike ? false : boolean;
/**
 * Returns a new list containing the contents of the given list, followed by the given value.
 *
 * @param val - The value to add to the end of the new list
 * @param list - The list of elements to add a new item to
 * @returns The result of `[...list, val]`
 *
 * @example
 * ```ts
 * append('Tom', ['hello']) // ['hello', 'Tom']
 * append('Tom', []) // ['Tom']
 * append(['Tom'], ['hello', 'world']) // ['hello', 'world', ['Tom']]
 * ```
 *
 * @see Related to {@link prepend}
 *
 * @category `Array`
 *
 * @public
 */
declare const append: <T, U>(val: T, list: U[]) => (T | U)[];
/**
 * Return an array of elements split into groups the length of size.
 *
 * @param size - The length of each chunk
 * @param array - The array to process
 * @returns Returns the new array of chunks
 *
 * @remarks
 * If array can't be split evenly, the final chunk will be the remaining elements.
 *
 * @example
 * ```ts
 * // Basic
 * chunk(1, ['a', 'b', 'c', 'd']) // [['a'], ['b'], ['c'], ['d']]
 * chunk(3, ['a', 'b', 'c', 'd']) // [['a', 'b', 'c'], ['d']]
 * chunk(5, ['a', 'b', 'c', 'd']) // [['a', 'b', 'c', 'd']]
 * ```
 *
 * @example
 * ```ts
 * // Illegal size
 * chunk(0, ['a', 'b', 'c']) // ['a', 'b', 'c']
 * chunk(-3, ['a', 'b', 'c']) // ['a', 'b', 'c']
 * chunk(5, []) // []
 * ```
 *
 * @category `Array`
 *
 * @public
 */
declare const chunk: <T extends number, U extends readonly unknown[]>(size: T, array: U) => T extends 0 ? U : `${T}` extends `-${number}` ? U : U extends readonly [
] ? U : U extends readonly (infer R)[] ? R[][] : never;
/**
 * Safe getter for `constructor.name`.
 * @param val - Any value
 * @returns If `val` is `null` or `undefined`, empty string; otherwise `constructor.name`
 *
 * @example
 * ```ts
 * constructorName(null) // ''
 * constructorName(undefined) // ''
 * constructorName({}) // 'Object'
 * constructorName('') // 'String'
 * ```
 *
 * @public
 */
declare const constructorName: (val: unknown) => string;
/**
 * Decrements its argument.
 *
 * @param val - input `number` or `bigint`
 * @returns Decremented `val`
 *
 * @example
 * ```ts
 * dec(100) // 99
 * dec(10n) // 9n
 * ```
 *
 * @see Related to {@link inc}
 *
 * @public
 */
declare const dec: {
    (val: number): number;
    (val: bigint): bigint;
};
/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`; otherwise the first argument is returned.
 *
 * @param a - `a` will be returned instead of `default`
 * @returns Returns a function that stores the default `a` value. The function accept `b` argument.
 * if `b` is `null`, `undefined` or `NaN`, return `a`; otherwise return `b`
 *
 * @example
 * ```ts
 * const defaultVal = defaultTo('anonymous')
 * defaultVal(undefined) // 'anonymous'
 * defaultVal(null) // 'anonymous'
 * defaultVal(NaN) // 'anonymous'
 *
 * defaultVal('Tom') // 'Tom'
 * ```
 *
 * @public
 */
declare const defaultTo: <T extends unknown>(a: T) => <U extends unknown>(b: U) => U extends null | undefined ? T : U extends number ? U : T | U;
// re-export
/**
 * Divide its second argument from its first argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a / b`
 
 * @remarks
 * Since division is not idempotent, there are two ways to curry.
 *
 * @example
 * ```ts
 * // Number
 * divide(10, 100) // 0.1
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * divide(1n, 2n) // 3n
 * ```
 *
 * @example
 * ```ts
 * // First argument curry
 * const reciprocal = divide(1)
 * reciprocal(4) // 0.25
 * ```
 *
 * @example
 * ```ts
 * // Second argument curry
 * import { _ } from 'fonction'
 * const half = divide(_, 2)
 * half(20) // 10
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link subtract} {@link multiply}
 *
 * @public
 */
declare const divide: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
} & {
    (a: typeof _, b: number): (a: number) => number;
    (a: typeof _, b: bigint): (a: bigint) => bigint;
};
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles cyclical data structures.
 *
 * @param a - Input any value
 * @param b - Input any value
 * @returns Return `true` if the reference memory is the same or the property members and their values are the same
 *
 * @example
 * ```ts
 * equals(-0, 0) // true
 * equals(NaN, NaN) // true
 * equals([[[[]]]], [[[[]]]]) // true
 * equals({ a: { b: [1, 2, 3]}}, { a: { b: [1, 2, 3]}}) // true
 * ```
 *
 * @public
 */
declare const equal: <T, U extends T>(a: T, b: U) => boolean;
/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @returns false
 *
 * @example
 * ```ts
 * F() // false
 * F(1, 'hello', 'world') // false
 * ```
 *
 * @see Related to {@link T}
 *
 * @public
 */
declare const F: AnyFn<unknown, false>;
/**
 * Infer deep flatted array.
 *
 * @typeParam T - input any array
 * @returns Deep flatted array
 *
 * @example
 * ```ts
 * FlattenDeep<[]> // []
 * FlattenDeep<[[1, [2, [3, [4]], 5]]> // [1, 2, 3, 4, 5]
 * ```
 *
 * @category `Array`
 *
 * @public
 */
type FlattenDeep<T extends readonly unknown[]> = T extends readonly [
    infer A,
    ...infer Rest
] ? A extends readonly unknown[] ? [
    ...FlattenDeep<A>,
    ...FlattenDeep<Rest>
] : [
    A,
    ...FlattenDeep<Rest>
] : [
    ...T
];
/**
 * Recursively flattens array.
 *
 * @param val - The `array` to flatten
 * @returns The result of `val.flat(Infinity)`
 *
 * @example
 * ```ts
 * flattenDeep([]) // []
 * flattenDeep([1, [2, [3, [4]], 5]]) // [1, 2, 3, 4, 5]
 * ```
 *
 * @public
 */
declare const flattenDeep: <T extends readonly unknown[]>(val: T) => FlattenDeep<T>;
/**
 * Returns `true` if the first argument is greater than the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a > b`
 *
 * @example
 * ```ts
 * // Number
 * gt(2, 1) // true
 * gt(2, 2) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * gt(2n, 1n) // true
 * gt(2n, 2n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * gt('z', 'a') // true
 * gt('a', 'z') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * gt(true, false) // true
 * gt(false, true) // false
 * gt(true, true) // false
 * gt(false, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * gt(new Date('2000/1/2'), new Date('2000/1/1')) // true
 * gt(new Date('1999/12/31'), new Date('2000/1/1')) // false
 * gt(new Date('2000/1/1'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link gte} {@link lt} {@link lte}
 *
 * @public
 */
declare const gt: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns `true` if the first argument is greater than or equal to the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a >= b`
 *
 * @example
 * ```ts
 * // Number
 * gte(2, 1) // true
 * gte(2, 2) // true
 * gte(2, 3) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * gte(2n, 1n) // true
 * gte(2n, 2n) // true
 * gte(2n, 3n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * gte('z', 'a') // true
 * gte('a', 'a') // true
 * gte('a', 'z') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * gte(true, false) // true
 * gte(true, true) // true
 * gte(false, false) // true
 * gte(false, true) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * gte(new Date('2000/1/2'), new Date('2000/1/1')) // true
 * gte(new Date('2000/1/1'), new Date('2000/1/1')) // true
 * gte(new Date('1999/12/31'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link gt} {@link lt} {@link lte}
 *
 * @public
 */
declare const gte: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns whether or not an object has an own property with the specified name.
 *
 * @param props - The name of the property to check for
 * @param obj - The check object
 * @returns The result of `Object.prototype.hasOwnProperty`
 *
 * @example
 * ```ts
 * // Flat
 * has('hello', { hello: 'world' }) // true
 * has(0, { 0 : 1}) // true
 * has('', {}) // false
 * has('hello', { hi : hello: 'world' }) // false
 * ```
 *
 * @example
 * ```ts
 * // Nest
 * hasPath(['hello'], { hello: 'world' }) // true
 * hasPath([0], { 0: 1 }) // true
 * hasPath(['hello', 'world'], { hello: { world: '' } } // true
 *
 * hasPath(['hi'], { hello: '' } ) // false
 * hasPath(['hi', 'Tom'], { hi: { John: 1 } } ) // false
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link props}
 *
 * @public
 */
declare const has: <T extends string | number | (string | number)[], U extends Record<PropertyKey, unknown>>(props: T, obj: U) => T extends unknown[] ? boolean : T extends string | number ? U extends Record<T, unknown> ? true : false : never;
/**
 * Return the parameter supplied to it.
 *
 * @param val - The value to return
 * @returns The result of `val`
 *
 * @example
 * ```ts
 * identity(1) // 1
 * identity({}) // {}
 * ```
 *
 * @public
 */
declare const identity: <T>(val: T) => T;
/**
 * Return the `onTrue` or the `onFalse` value depending upon the result of the condition `val`.
 *
 * @param val - A predicate value
 * @param onTrue - The `val` evaluates to a truthy value
 * @param onFalse - The `val` evaluates to a falsy value
 * @returns The result of `!!val` ? `onTrue` : `onFalse` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 *
 * @example
 * ```ts
 * ifElse(true, 1, 0) // 1
 * ifElse(false, 1, 0) // 0
 * ifElse(undefined, 1, 0) // 0
 * ifElse(() => true, () => 1, () => 0) // 1
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link ifElseFn}
 *
 * @public
 */
declare const ifElse: <V, T, F>(val: V | AnyFn<any, V>, onTrue: T | AnyFn<any, T>, onFalse: F | AnyFn<any, F>) => V extends FalsyLike ? F : V extends true ? T : T | F;
/**
 * Creates a function that will process either the `onTrue` or the `onFalse` function depending upon the result of the condition predicate.
 *
 * @param condition - A predicate function
 * @param onTrue - Any value or A function to invoke when the `condition` evaluates to a truthy value
 * @param onFalse - Any value or A function to invoke when the `condition` evaluates to a falsy value
 * @returns A new function that will process either the `onTrue` or the `onFalse` function depending upon the result of the `condition` predicate
 *
 * @example
 * ```ts
 * ifElseFn((x: number) => x > 10, 'big', 'small')(20) // 'big'
 * const fn = ifElseFn((x: number) => x > 10, (x) => x + 1, (x) => x - 1)
 * fn(11) // 12
 * fn(9) // 8
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link ifElse}
 *
 * @public
 */
declare const ifElseFn: <V, R, T, F>(condition: (val: V) => R, onTrue: T | ((val: V) => T), onFalse: F | ((val: V) => F)) => (val: V) => R extends true ? T : R extends FalsyLike ? F : T | F;
/**
 * Increments its argument.
 *
 * @param val - Input `number` or `bigint`
 * @returns Incremented `val`
 *
 * @example
 * ```ts
 * inc(100) // 101
 * inc(10n) // 11n
 * ```
 *
 * @see Related to {@link dec}
 *
 * @public
 */
declare const inc: {
    (val: number): number;
    (val: bigint): bigint;
};
/**
 * K combinator. Returns a function that always returns the given value.
 *
 * @param val - The value to wrap in a function
 * @returns Function wrapped `val`
 *
 * @example
 * ```ts
 * const k = K('k')
 * k() // 'k'
 * ```
 *
 * @public
 */
declare const K: <T extends unknown>(val: T) => () => T;
/**
 * Returns `true` if the first argument is less than the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a < b`
 *
 * @example
 * ```ts
 * // Number
 * lt(1, 2) // true
 * lt(2, 2) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * lt(1n, 2n) // true
 * lt(2n, 2n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * lt('a', 'z') // true
 * lt('a', 'a') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * lt(false, true) // true
 * lt(true, true) // false
 * lt(false, false) // false
 * lt(true, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * lt(new Date('1999/12/31'), new Date('2000/1/1')) // true
 * lt(new Date('2000/1/1'), new Date('2000/1/1')) // false
 * lt(new Date('2000/1/2'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link lte} {@link gt} {@link gte}
 *
 * @public
 */
declare const lt: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns `true` if the first argument is less than or equal to the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a <= b`
 *
 * @example
 * ```ts
 * // Number
 * lte(1, 2) // true
 * lte(2, 2) // true
 * lte(2, 1) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * lte(1n, 2n) // true
 * lte(2n, 2n) // true
 * lte(2n, 1n) // true
 * ```
 *
 * @example
 * ```ts
 * // String
 * lte('a', 'z') // true
 * lte('a', 'a') // true
 * lte('z', 'a') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * lte(true, true) // true
 * lte(false, false) // true
 * lte(false, true) // true
 * lte(true, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * lte(new Date('2000/1/1'), new Date('2000/1/1')) // true
 * lte(new Date('1999/12/31'), new Date('2000/1/1')) // true
 * lte(new Date('2000/1/2'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link lt} {@link gt} {@link gte}
 *
 * @public
 */
declare const lte: <T extends Ord>(a: T, b: T) => boolean;
// re-export
/**
 * Multiplies first argument and second argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a * b`
 *
 * @example
 * ```ts
 * // Basic
 * multiply(2, 3) // 6
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * multiply(2n, 3n) // 6n
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const double = multiply(2)
 * double(4) // 8
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link subtract} {@link divide}
 *
 * @public
 */
declare const multiply: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
};
/**
 * Returns the `!` of its argument.
 *
 * @param val - Input any value
 * @returns The result of `!val`
 *
 * @remarks
 * The Definition of Falsy
 * - `''`
 * - `false`
 * - `0`
 * - `NaN`
 * - `undefined`
 * - `null`
 *
 * @example
 * ```ts
 * N('') // true
 * N(false) // true
 * N(0) // true
 * N(NaN) // true
 * N(undefined) // true
 * N(null) // true
 *
 * N({}) // false
 * N([]) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link NN}
 *
 * @public
 */
declare const N: <T>(val: T) => T extends FalsyLike ? true : boolean;
/**
 * Abbreviation for Not Not. Returns the `!!` of its argument.
 *
 * @param val - Input any value
 * @returns The result of `!!val`
 *
 * @remarks
 * The Definition of Falsy
 * - `''`
 * - `false`
 * - `0`
 * - `NaN`
 * - `undefined`
 * - `null`
 *
 * @example
 * ```ts
 * NN('') // false
 * NN(false) // false
 * NN(0) // false
 * NN(NaN) // false
 * NN(undefined) // false
 * NN(null) // false
 *
 * NN({}) // true
 * NN([]) // true
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link N}
 *
 * @public
 */
declare const NN: <T>(val: T) => T extends FalsyLike ? false : boolean;
/**
 * Returns the function as is with return value `!`.
 *
 * @param val - Input any `function`
 * @returns The result is function what return value with `!`
 *
 * @example
 * ```ts
 * not(() => true)() // false
 * const gt10 = (val: number) => val > 10
 * not(gt10)(11) // false
 * ```
 *
 * @public
 */
declare const not: <T extends AnyFn<any, unknown>>(fn: T) => (...val: Parameters<T>) => boolean;
/**
 * Returns true if one or both of its arguments are true; otherwise false.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!!a || !!bb` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 
 * @example
 * ```ts
 * or(true, true) // true
 * or(false, true) // true
 * or(true, false) // true
 * or(false, false) // false
 *
 * or(() => 0, () => 1) // true
 * or(() => 0, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link and} {@link xor}
 *
 * @public
 */
declare const or: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? U extends FalsyLike ? false : boolean : boolean;
/**
 * Performs left-to-right function composition.
 *
 * @param functions - Multi any functions
 * @returns A `function` what argument is `function[0]` argument
 *
 * @remarks
 * The first argument may have any arity; the remaining arguments must be unary.
 *
 * @example
 * ```ts
 * const fn = pipe(add , inc)
 * fn(1, 1) // 3
 * ```
 *
 * @public
 */
declare const pipe: Pipe;
type Pipe = {
    <F1 extends AnyFn>(fn1: F1): (...initialArg: Parameters<F1>) => ReturnType<F1>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>>(...fn1: [
        F1,
        F2
    ]): (...initialArg: Parameters<F1>) => ReturnType<F2>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>>(...fn1: [
        F1,
        F2,
        F3
    ]): (...initialArg: Parameters<F1>) => ReturnType<F3>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>>(...fn1: [
        F1,
        F2,
        F3,
        F4
    ]): (...initialArg: Parameters<F1>) => ReturnType<F4>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5
    ]): (...initialArg: Parameters<F1>) => ReturnType<F5>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6
    ]): (...initialArg: Parameters<F1>) => ReturnType<F6>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7
    ]): (...initialArg: Parameters<F1>) => ReturnType<F7>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8
    ]): (...initialArg: Parameters<F1>) => ReturnType<F8>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9
    ]): (...initialArg: Parameters<F1>) => ReturnType<F9>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10
    ]): (...initialArg: Parameters<F1>) => ReturnType<F10>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11
    ]): (...initialArg: Parameters<F1>) => ReturnType<F11>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12
    ]): (...initialArg: Parameters<F1>) => ReturnType<F12>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13
    ]): (...initialArg: Parameters<F1>) => ReturnType<F13>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14
    ]): (...initialArg: Parameters<F1>) => ReturnType<F14>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15
    ]): (...initialArg: Parameters<F1>) => ReturnType<F15>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>, F16 extends Arity1Fn<ReturnType<F15>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16
    ]): (...initialArg: Parameters<F1>) => ReturnType<F16>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>, F16 extends Arity1Fn<ReturnType<F15>>, F17 extends Arity1Fn<ReturnType<F16>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16,
        F17
    ]): (...initialArg: Parameters<F1>) => ReturnType<F17>;
};
/**
 * Returns a new list with the given value at the front, followed by the contents of the list.
 *
 * @param val - The value to add to the front of the new list
 * @param list - The list of elements to add a new item to
 * @returns The result of `[val, ...list]`
 *
 * @example
 * ```ts
 * prepend('Tom', ['hello']) // ['Tom', 'hello']
 * prepend('Tom', []) // ['Tom']
 * prepend(['Tom'], ['hello', 'world']) // [['Tom'], 'hello', 'world']
 * ```
 *
 * @category `Array`
 *
 * @see Related to {@link append}
 *
 * @public
 */
declare const prepend: <T, U>(val: T, list: U[]) => (T | U)[];
/**
 * Multiplies together all the elements of a list.
 *
 * @param val - list An array of numbers
 * @returns The product of all the numbers in the list
 *
 * @example
 * ```ts
 * product([1, 2, 3, 4, 5]) // 120
 * product([1n, 2n, 3n, 4n, 5n]) //120n
 * product([]) // 0
 * ```
 *
 * @category `Math`
 *
 * @public
 */
declare const product: {
    (val: [
    ]): 0;
    (val: number[]): number;
    (val: bigint[]): bigint;
};
/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 *
 * @param val - Input property key
 * @param obj - The object to query
 * @returns The result of safety `obj[val]` or `obj[val[0]][val[1]][val[...x]]`
 *
 * @example
 * ```ts
 * props('x', { x: 'hello' }) // 'hello'
 * props(1, { 1: 100 }) // 100
 * props('x', {}) // undefined
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link has}
 *
 * @public
 */
declare const props: <T extends string | number, U extends Record<PropertyKey, unknown>>(val: T, obj: U) => U extends Record<T, unknown> ? U[T] : undefined;
// re-export
/**
 * Subtracts its second argument from its first argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a - b`
 *
 * @remarks
 * Since subtraction is not idempotent, there are two ways to curry.
 *
 * @example
 * ```ts
 * // Number
 * subtract(2, 1) // 1
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * subtract(3n, 2n) //1n
 * ```
 *
 * @example
 * ```ts
 * // First argument curry
 * const from5Minus = subtract(5)
 * from5Minus(10) // -5
 * ```
 *
 * @example
 * ```ts
 * // Second argument curry
 * import { _ } from 'fonction'
 * const minus5 = (_, 5)
 * minus5(20) // 15
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link multiply} {@link divide}
 *
 * @public
 */
declare const subtract: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
} & {
    (a: typeof _, b: number): (a: number) => number;
    (a: typeof _, b: bigint): (a: bigint) => bigint;
};
/**
 * Adds together all the elements of a list.
 *
 * @param val - list An array of numbers
 * @returns The sum of all the numbers in the list
 *
 * @example
 * ```ts
 * sum([1, 2, 3, 4, 5]) // 15
 * sum([1n, 2n, 3n, 4n, 5n]) // 15n
 * sum([]) // 0
 * ```
 *
 * @category `Math`
 *
 * @public
 */
declare const sum: {
    (val: [
    ]): 0;
    (val: number[]): number;
    (val: bigint[]): bigint;
};
/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @returns `True`
 *
 * @example
 * ```ts
 * T() // true
 * T(1, 'hello', 'world') // true
 * ```
 *
 * @see Related to {@link F}
 *
 * @public
 */
declare const T: AnyFn<unknown, true>;
/**
 * Return a slice of string or array with `n` elements taken from the beginning.
 *
 * @param howMany - The number of elements to take
 * @param val - `String` or `Array` to query
 * @returns The slice of array
 *
 * @example
 * ```ts
 * // String
 * take(3, 'hello') // 'hel'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * take(3, [1, 2, 3, 4]) // [1, 2, 3]
 * ```
 *
 * @category `String` `Array`
 *
 * @see Related to {@link slice} {@link takeLast}
 *
 * @public
 */
declare const take: <T extends string | readonly unknown[]>(howMany: number, val: T) => T;
/**
 * Return a slice of string or array with `n` elements taken from the end.
 *
 * @param howMany - The number of elements to take
 * @param val - `String` or `Array` to query
 * @returns The slice of array
 *
 * @example
 * ```ts
 * // String
 * takeLast(3, 'hello') // 'llo'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * takeLast(3, [1, 2, 3, 4]) // [2, 3, 4]
 * ```
 *
 * @category `String` `Array`
 *
 * @see Related to {@link take}
 *
 * @public
 */
declare const takeLast: <T extends string | readonly unknown[]>(howMany: number, val: T) => T;
/**
 * Runs the given function with the supplied value, then returns the value.
 *
 * @param fn - The function to call with `val`. The return value of fn will be thrown away.
 * @returns The result of `(val) => fn(val)`
 *
 * @example
 * ```ts
 * tap(console.log)('hello') // hello
 * // log: hello
 * ```
 *
 * @public
 */
declare const tap: <T>(fn: Arity1Fn<T, unknown>) => <R extends T>(val: R) => R;
/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned function evaluates the `tryer`; if it does not throw, it simply returns the result. If the `tryer` does throw, the returned function evaluates the catcher function and returns its result.
 *
 * @param tryer - The function that may throw.
 * @param catcher - The function that will be evaluated if tryer throws.
 * @returns - The result of `try { tryer() } catch(e) { catcher(e) }`
 *
 * @example
 * ```ts
 * tryCatch(() => { throw Error('error') }) // Error('error')
 * tryCatch(() => { throw Error('error') }, 0) // 0
 * tryCatch(() => { throw Error('error') }, (e: Error) => e.message ) // 'error'
 * ```
 *
 * @category `Logic`
 *
 * @public
 */
declare const tryCatch: <R, E, P = unknown>(tryer: AnyFn<any, R>, catcher?: E | AnyFn<P, E> | undefined) => R | E;
/**
 * Returns a new `Array` containing only one copy of each element in the original array. `equal` is used to determine equality.
 *
 * @param val - Input any `array`
 * @returns The list of unique items
 *
 * @example
 * ```ts
 * uniq([1, 2, 1, 1]) // [1, 2]
 * uniq([{}, {}, [], []]) // [{}, []]
 * uniq([[1, 2, 3], [1, 2, 3]]) // [[1, 2, 3]]
 * ```
 *
 * @category `Array`
 *
 * @see Related to {@link equal}
 *
 * @public
 */
declare const uniq: <T extends unknown>(val: readonly T[]) => T[];
/**
 * Returns true if one of the arguments is truthy and the other is falsy; otherwise false.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!a !== !b` (if argument is function, return value)
 *
 * @example
 * ```ts
 * xor(true, false) // true
 * xor(false, true) // true
 * xor(true, true) // false
 * xor(false, false) // false
 * xor(() => 1, () => 0) // true
 * xor(() => 0, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link and} {@link or}
 *
 * @public
 */
declare const xor: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? U extends FalsyLike ? false : boolean : boolean;
//# sourceMappingURL=index.es.d.ts.map

export { AnyFn, Arity1Fn, Empty, F, FalsyLike, FlattenDeep, Head, Init, K, Last, N, NN, Ord, Primitive, Space, T, Tail, TypedArray, _, add, advance, and, append, chunk, constructorName, curry, dec, defaultTo, divide, equal, flattenDeep, gt, gte, has, head, identity, ifElse, ifElseFn, inc, init, last, lt, lte, multiply, not, or, pipe, prepend, product, props, subtract, sum, tail, take, takeLast, tap, tryCatch, uniq, xor };
