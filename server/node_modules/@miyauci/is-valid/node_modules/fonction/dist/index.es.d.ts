/**
 * Placeholder to indicate that the argument is not explicitly set.
 *
 * @returns The results of `Symbol('_')`
 *
 * @public
 */
declare const _: unique symbol;//# sourceMappingURL=index.es.d.ts.map

// Copyright 2021-present the Curry authors. All rights reserved. MIT license.
// deno-lint-ignore-file no-explicit-any
/**
 * Alias for Any array types
 *
 * @internal
 */
type AnyArray = readonly unknown[];
/**
 * @internal
 */
type Union2Intersection<U> = (U extends unknown ? (arg: U) => void : never) extends (arg: infer I) => void ? I : never;
/**
 * Pop types
 * @typeParams - T Any array
 * @example
 * ```ts
 * Pop<[1, 2, 3]> = [1, 2].
 * ```
 *
 * @internal
 */
type Pop<T extends AnyArray> = T extends [
    ...infer Head,
    unknown
] ? Head : T extends readonly [
    ...infer Head,
    unknown
] ? readonly [
    ...Head
] : never;
/**
 * Shift types
 * @typeParams S - Any array
 * @example
 * ```ts
 * Shift<[1], [1, 2, 3]> = [2, 3].
 * Shift<[1, 2], [1, 2, 3]> = [3].
 * ```
 *
 * @internal
 */
type Shift<S extends AnyArray, T extends AnyArray> = T extends [
    ...S,
    ...infer Rest
] ? Rest : never;
/**
 * @example
 * ```ts
 * UnionFactorial<[1, 2, 3]> = [1] | [1, 2] | [1, 2, 3].
 * ```
 *
 * @internal
 */
type UnionFactorial<T extends AnyArray> = T extends readonly [
] ? never : T | UnionFactorial<Pop<T>>;
/**
 * @example
 * ```ts
 * OverloadsByArgs<[1] | [1, 2], [1, 2, 3], 7> =
 *  | CurriedWithFixArgs<[1], [2, 3], 7>
 *  | CurriedWithFixArgs<[1, 2], [3], 7>.
 * ```
 *
 * @internal
 */
type OverloadsByArgs<Args extends AnyArray, FullArgs extends AnyArray, ReturnValue> = Args extends unknown ? CurriedWithFixArgs<Args, Shift<Args, FullArgs>, ReturnValue> : never;
/**
 * @internal
 */
type CurriedWithFixArgs<Args extends AnyArray, RestArgs extends AnyArray, ReturnValue> = (...args: Args) => Curried<RestArgs, ReturnValue>;
/**
 * Curry types
 *
 * @internal
 */
type Curried<Args extends AnyArray, ReturnValue> = Args extends [
] ? ReturnValue : Union2Intersection<OverloadsByArgs<UnionFactorial<Args>, Args, ReturnValue>>;
/**
 * Creates a function that accepts arguments of `fn` and either invokes `fn` returning its result, if at least arity number of arguments have been provided, or returns a function that accepts the remaining `fn` arguments, and so on.
 *
 * @param fn - The function to curry
 * @returns The new curried function
 *
 * @remarks
 * Maximum number of arity is `19`. Beyond that, the type system will breaks.
 *
 * @example
 * ```ts
 * const replace = (from: string, to: string, val: string) => val.replace(from, to)
 * const curriedReplace = curry(replace)
 * const curriedReplace('hello', 'hi', 'hello world') // 'hi world'
 * const curriedReplace('hello')('hi', 'hello world') // 'hi world'
 * const curriedReplace('hello')('hi')('hello world') // 'hi world'
 * ```
 *
 * @beta
 */
declare const curry: <T extends unknown[], R>(fn: (...args: T) => R) => T["length"] extends 0 ? () => R : Curried<T, R>;
//# sourceMappingURL=index.es.d.ts.map

// re-export
/**
 * Adds first argument and second argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a + b`
 *
 * @example
 * ```ts
 * // Basic
 * add(1, 2) // 3
 * ```
 * @example
 * ```ts
 * // Bigint
 * add(1n, 2n) // 3n
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const plus2(2)
 * plus2(-3) // -1
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link subtract} {@link multiply} {@link divide}
 *
 * @public
 */
declare const add: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
};
// Copyright 2021-present the Fonction authors. All rights reserved. MIT license.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Type of any function.
 *
 * @public
 *
 * @typeParam T - Argument types
 */
type AnyFn<T = any, U = unknown> = (...args: T[]) => U;
/**
 * Type of arity 1 function.
 *
 * @public
 *
 * @typeParam T - Argument types
 */
type Arity1Fn<T = any, U = unknown> = (args: T) => U;
/**
 * Alias for Primitive values types.
 *
 * @category `Alias`
 *
 * @public
 *
 */
type Primitive = string | number | bigint | boolean | symbol | undefined | null;
/**
 * Abbreviation for Ordinal.
 *
 * @category `Alias`
 *
 * @public
 */
type Ord = string | number | bigint | boolean | Date;
/**
 * Alias for Empty values
 *
 * @category `Alias`
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/ban-types
type Empty = "" | [
] | {};
/**
 * Alias for Falsy values.
 *
 * @category `Alias`
 *
 * @public
 * @deprecated
 * Rename to `FalsyLike`
 */
type Falsy = false | "" | 0 | null | undefined;
/**
 * Alias for Falsy values.
 *
 * @remarks
 * This is not a strict `Falsy`. TypeScript type system cannot define `NaN`.
 *
 * @category `Alias`
 *
 * @public
 */
type FalsyLike = false | "" | 0 | 0n | null | undefined;
/**
 * Alias for Space values.
 *
 * @category `Alias`
 *
 * @public
 */
type Space = " " | "\n" | "\t";
/**
 * Convert `string` to `array` types.
 *
 * @typeParam T - Any string
 * @returns String array
 *
 * @example
 * ```ts
 * String2Array<string> string[]
 * String2Array<''> // []
 * String2Array<'hello'> // ["h", "e", "l", "l", "o"]
 * ```
 *
 * @internal
 */
type String2Array<T extends string> = T extends "" ? [
] : T extends `${infer F}${infer R}` ? [
    F,
    ...String2Array<R>
] : string[];
/**
 * Returns return value if argument is `function`; otherwise returns the value as it is.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'function' ? val(): val`
 *
 * @example
 * ```ts
 * advance(1) // 1
 * advance(() => 1) // 1
 * ```
 *
 * @category `Logic`
 *
 * @public
 */
declare const advance: <T>(val: T | AnyFn<any, T>) => T;
/**
 * Returns `true` if both arguments are true; otherwise `false`.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!!a && !!bb` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 *
 * @example
 * ```ts
 * and(true, true) // true
 * and(false, true) // false
 * and(true, false) // false
 * and(false, false) // false
 * and(() => 1, () => 2) // true
 * and(() => 1, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link or} {@link xor}
 *
 * @public
 */
declare const and: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? false : U extends FalsyLike ? false : boolean;
/**
 * Returns a new list containing the contents of the given list, followed by the given value.
 *
 * @param val - The value to add to the end of the new list
 * @param list - The list of elements to add a new item to
 * @returns The result of `[...list, val]`
 *
 * @example
 * ```ts
 * append('Tom', ['hello']) // ['hello', 'Tom']
 * append('Tom', []) // ['Tom']
 * append(['Tom'], ['hello', 'world']) // ['hello', 'world', ['Tom']]
 * ```
 *
 * @see Related to {@link prepend}
 *
 * @category `Array`
 *
 * @public
 */
declare const append: <T, U>(val: T, list: U[]) => (T | U)[];
/**
 * Return an array of elements split into groups the length of size.
 *
 * @param size - The length of each chunk
 * @param array - The array to process
 * @returns Returns the new array of chunks
 *
 * @remarks
 * If array can't be split evenly, the final chunk will be the remaining elements.
 *
 * @example
 * ```ts
 * // Basic
 * chunk(1, ['a', 'b', 'c', 'd']) // [['a'], ['b'], ['c'], ['d']]
 * chunk(3, ['a', 'b', 'c', 'd']) // [['a', 'b', 'c'], ['d']]
 * chunk(5, ['a', 'b', 'c', 'd']) // [['a', 'b', 'c', 'd']]
 * ```
 *
 * @example
 * ```ts
 * // Illegal size
 * chunk(0, ['a', 'b', 'c']) // ['a', 'b', 'c']
 * chunk(-3, ['a', 'b', 'c']) // ['a', 'b', 'c']
 * chunk(5, []) // []
 * ```
 *
 * @category `Array`
 *
 * @public
 */
declare const chunk: <T extends number, U extends readonly unknown[]>(size: T, array: U) => T extends 0 ? U : `${T}` extends `-${number}` ? U : U extends readonly [
] ? U : U extends readonly (infer R)[] ? R[][] : never;
/**
 * Safe getter for `constructor.name`.
 * @param val - Any value
 * @returns If `val` is `null` or `undefined`, empty string; otherwise `constructor.name`
 *
 * @example
 * ```ts
 * constructorName(null) // ''
 * constructorName(undefined) // ''
 * constructorName({}) // 'Object'
 * constructorName('') // 'String'
 * ```
 *
 * @public
 */
declare const constructorName: (val: unknown) => string;
/**
 * Decrements its argument.
 *
 * @param val - input `number` or `bigint`
 * @returns Decremented `val`
 *
 * @example
 * ```ts
 * dec(100) // 99
 * dec(10n) // 9n
 * ```
 *
 * @see Related to {@link inc}
 *
 * @public
 */
declare const dec: {
    (val: number): number;
    (val: bigint): bigint;
};
/**
 * Null or not.
 *
 * @typeParam T - Any value
 *
 * @public
 */
type IsNull<T extends unknown> = T extends null ? true : false;
/**
 * Whatever argument is type of `null` or not.
 *
 * @param val - Input any value
 * @returns The result of `val === null`
 *
 * @example
 * ```ts
 * isNull(null) // true
 * isNull(undefined) // false
 * ```
 *
 * @public
 */
declare const isNull: (val: unknown) => val is null;
/**
 * Undefined or not.
 *
 * @typeParam T - Any value
 *
 * @public
 */
type IsUndefined<T extends unknown> = T extends undefined ? true : false;
/**
 * Whatever argument is type of `undefined` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'undefined'`
 *
 * @example
 * ```ts
 * isUndefined(undefined) // true
 * isUndefined('hello') // false
 * ```
 *
 * @public
 */
declare const isUndefined: (val: unknown) => val is undefined;
/**
 * Undefiled or null, or not.
 *
 * @typeParam T - Any value
 *
 * @public
 */
type IsNil<T extends unknown> = IsUndefined<T> extends true ? true : IsNull<T> extends true ? true : false;
/**
 * Whatever argument is type of `undefined` or `null`.
 *
 * @param val - Input any value
 * @returns The result of type of `val` is `undefined` or `null`
 *
 * @example
 * ```ts
 * isNil(undefined) // true
 * isNil(null) // true
 * isNil([]) // false
 * ```
 *
 * @public
 *
 */
declare const isNil: (val: unknown) => val is null | undefined;
/**
 * Number or not.
 *
 * @typeParam T - Any value
 *
 * @public
 */
type IsNumber<T extends unknown> = T extends number ? true : false;
/**
 * Whatever argument is type of `number` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'number'`
 *
 * @example
 * ```ts
 * isNumber(0) // true
 * isNumber('hello') // false
 * ```
 *
 * @public
 */
declare const isNumber: (val: unknown) => val is number;
/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`; otherwise the first argument is returned.
 *
 * @param a - `a` will be returned instead of `default`
 * @returns Returns a function that stores the default `a` value. The function accept `b` argument.
 * if `b` is `null`, `undefined` or `NaN`, return `a`; otherwise return `b`
 *
 * @example
 * ```ts
 * const defaultVal = defaultTo('anonymous')
 * defaultVal(undefined) // 'anonymous'
 * defaultVal(null) // 'anonymous'
 * defaultVal(NaN) // 'anonymous'
 *
 * defaultVal('Tom') // 'Tom'
 * ```
 *
 * @public
 */
declare const defaultTo: <T extends unknown>(a: T) => <U extends unknown>(b: U) => IsNil<U> extends true ? T : IsNumber<U> extends false ? U : T | U;
// re-export
/**
 * Divide its second argument from its first argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a / b`
 
 * @remarks
 * Since division is not idempotent, there are two ways to curry.
 *
 * @example
 * ```ts
 * // Number
 * divide(10, 100) // 0.1
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * divide(1n, 2n) // 3n
 * ```
 *
 * @example
 * ```ts
 * // First argument curry
 * const reciprocal = divide(1)
 * reciprocal(4) // 0.25
 * ```
 *
 * @example
 * ```ts
 * // Second argument curry
 * import { _ } from 'fonction'
 * const half = divide(_, 2)
 * half(20) // 10
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link subtract} {@link multiply}
 *
 * @public
 */
declare const divide: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
} & {
    (a: typeof _, b: number): (a: number) => number;
    (a: typeof _, b: bigint): (a: bigint) => bigint;
};
type EndsWith<T extends string | undefined = undefined> = T extends undefined ? (target: string) => ReturnType<string["endsWith"]> : ReturnType<string["endsWith"]>;
/**
 * Checks if a string ends with the provided substring.
 *
 * @param val - Search string
 * @param target - Target string
 * @returns The result of `target.endsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * endsWith('world', 'hello world') // true
 * endsWith('earth', 'hello world') // false
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const endsWithHtml = endsWith('html')
 * endsWithHtml('index.html') // true
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link startsWith}
 *
 * @public
 */
declare const endsWith: <T extends string, U extends string | undefined = undefined>(val: T, target?: U | undefined) => EndsWith<U>;
/**
 * Returns an array of key/values of the enumerable properties of an object.
 *
 * @param val - `Object` that contains the properties and methods
 * @returns The result of `Object.entries(val)`
 *
 * @remarks
 * The order of the output array is not guaranteed to be consistent across different JS platforms.
 *
 * @example
 * ```ts
 * entries({ a: 'b' }) // [['a', 'b']]
 * entries(['a', 'b', 'c']) // [['0', 'a'], ['1', 'b'], ['2', 'c']]
 * entries({}) // []
 * entries([]) // []
 * ```
 *
 * @category `Object` `Array`
 *
 * @see Related to {@link keys} {@link values}
 *
 * @public
 */
declare const entries$0: {
    <T>(val: {
        [key: string]: T;
    } | ArrayLike<T>): [string, T][];
    (val: Record<string, unknown>): [string, unknown][];
};
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles cyclical data structures.
 *
 * @param a - Input any value
 * @param b - Input any value
 * @returns Return `true` if the reference memory is the same or the property members and their values are the same
 *
 * @example
 * ```ts
 * equals(-0, 0) // true
 * equals(NaN, NaN) // true
 * equals([[[[]]]], [[[[]]]]) // true
 * equals({ a: { b: [1, 2, 3]}}, { a: { b: [1, 2, 3]}}) // true
 * ```
 *
 * @public
 */
declare const equal: <T, U extends T>(a: T, b: U) => boolean;
/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @returns false
 *
 * @example
 * ```ts
 * F() // false
 * F(1, 'hello', 'world') // false
 * ```
 *
 * @see Related to {@link T}
 *
 * @public
 */
declare const F: AnyFn<unknown, false>;
/**
 * Infer the first types.
 *
 * @typeParam T - `string` or any `array`
 * @returns First element of the `T`
 *
 * @example
 * ```ts
 * // String
 * First<string> // string
 * First<''> // ''
 * First<'hello'> // 'h'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * First<[] | never[] | readonly [] | readonly never[]> // undefined
 * First<['hello', 'world']> // 'hello'
 * First<string | number[]> // string | number
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link Last}
 *
 * @public
 */
type First<T extends readonly unknown[] | string> = T extends "" ? "" : T extends string ? String2Array<T> extends [
] ? string : String2Array<T>[0] : T extends readonly never[] | [
] ? undefined : T[0];
/**
 * Returns the first element of the given list or string.
 *
 * @param val - String or any array object
 * @returns The first element of the `val`
 *
 * @example
 * ```ts
 * // String
 * first('') // ''
 * first('hello') // 'h'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * first('hello', 'new', 'world') // 'hello'
 * first([]) // undefined
 * first(['one', 2, 3, 4]) // 'one'
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link last}
 *
 * @public
 */
declare const first: <T extends string | readonly unknown[]>(val: T) => First<T>;
/**
 * Infer deep flatted array.
 *
 * @typeParam T - input any array
 * @returns Deep flatted array
 *
 * @example
 * ```ts
 * FlattenDeep<[]> // []
 * FlattenDeep<[[1, [2, [3, [4]], 5]]> // [1, 2, 3, 4, 5]
 * ```
 *
 * @category `Array`
 *
 * @public
 */
type FlattenDeep<T extends readonly unknown[]> = T extends readonly [
    infer A,
    ...infer Rest
] ? A extends readonly unknown[] ? [
    ...FlattenDeep<A>,
    ...FlattenDeep<Rest>
] : [
    A,
    ...FlattenDeep<Rest>
] : [
    ...T
];
/**
 * Recursively flattens array.
 *
 * @param val - The `array` to flatten
 * @returns The result of `val.flat(Infinity)`
 *
 * @example
 * ```ts
 * flattenDeep([]) // []
 * flattenDeep([1, [2, [3, [4]], 5]]) // [1, 2, 3, 4, 5]
 * ```
 *
 * @public
 */
declare const flattenDeep: <T extends readonly unknown[]>(val: T) => FlattenDeep<T>;
/**
 * Returns `true` if the first argument is greater than the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a > b`
 *
 * @example
 * ```ts
 * // Number
 * gt(2, 1) // true
 * gt(2, 2) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * gt(2n, 1n) // true
 * gt(2n, 2n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * gt('z', 'a') // true
 * gt('a', 'z') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * gt(true, false) // true
 * gt(false, true) // false
 * gt(true, true) // false
 * gt(false, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * gt(new Date('2000/1/2'), new Date('2000/1/1')) // true
 * gt(new Date('1999/12/31'), new Date('2000/1/1')) // false
 * gt(new Date('2000/1/1'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link gte} {@link lt} {@link lte}
 *
 * @public
 */
declare const gt: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns `true` if the first argument is greater than or equal to the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a >= b`
 *
 * @example
 * ```ts
 * // Number
 * gte(2, 1) // true
 * gte(2, 2) // true
 * gte(2, 3) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * gte(2n, 1n) // true
 * gte(2n, 2n) // true
 * gte(2n, 3n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * gte('z', 'a') // true
 * gte('a', 'a') // true
 * gte('a', 'z') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * gte(true, false) // true
 * gte(true, true) // true
 * gte(false, false) // true
 * gte(false, true) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * gte(new Date('2000/1/2'), new Date('2000/1/1')) // true
 * gte(new Date('2000/1/1'), new Date('2000/1/1')) // true
 * gte(new Date('1999/12/31'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link gt} {@link lt} {@link lte}
 *
 * @public
 */
declare const gte: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns whether or not an object has an own property with the specified name.
 *
 * @param props - The name of the property to check for
 * @param obj - The check object
 * @returns The result of `Object.prototype.hasOwnProperty`
 *
 * @example
 * ```ts
 * // Flat
 * has('hello', { hello: 'world' }) // true
 * has(0, { 0 : 1}) // true
 * has('', {}) // false
 * has('hello', { hi : hello: 'world' }) // false
 * ```
 *
 * @example
 * ```ts
 * // Nest
 * hasPath(['hello'], { hello: 'world' }) // true
 * hasPath([0], { 0: 1 }) // true
 * hasPath(['hello', 'world'], { hello: { world: '' } } // true
 *
 * hasPath(['hi'], { hello: '' } ) // false
 * hasPath(['hi', 'Tom'], { hi: { John: 1 } } ) // false
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link props}
 *
 * @public
 */
declare const has: <T extends string | number | (string | number)[], U extends Record<PropertyKey, unknown>>(props: T, obj: U) => T extends unknown[] ? boolean : T extends string | number ? U extends Record<T, unknown> ? true : false : never;
/**
 * Returns whether or not a path exists in an object. Only the object's own properties are checked.
 *
 * @deprecated
 * This function will remove next major release.
 * `hasPath` merged `has` function.
 *
 * @param path - The path to use
 * @param obj - The object to check the path in
 * @returns Whether the path exists
 *
 * @example
 * ```ts
 * hasPath(['hello'], { hello: 'world' }) // true
 * hasPath([0], { 0: 1 }) // true
 * hasPath(['hello', 'world'], { hello: { world: '' } } // true
 *
 * hasPath(['hi'], { hello: '' } ) // false
 * hasPath(['hi', 'Tom'], { hi: { John: 1 } } ) // false
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link has}
 *
 *
 * @public
 */
declare const hasPath: <T extends unknown>(path: (string | number)[], obj: Record<PropertyKey, T>) => boolean;
/**
 * Returns all but the last element of the given list or string.
 *
 * @param val - string or any array object
 * @returns The result of `val.slice(0, -1)`
 *
 * @example
 * ```ts
 * // String
 * head('hello') // 'hell'
 * head('h') // ''
 * head('') // ''
 * ```
 *
 * @example
 * ```ts
 * head([1, 2, 3]) // [1, 2]
 * head(['hello', 'world']) // ['hello']
 * head(['hello']) // []
 * head([]) // []
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link tail}
 *
 * @public
 */
declare const head: {
    (val: string): string;
    <T extends unknown[]>(val: T): T;
};
/**
 * Return the parameter supplied to it.
 *
 * @param val - The value to return
 * @returns The result of `val`
 *
 * @example
 * ```ts
 * identity(1) // 1
 * identity({}) // {}
 * ```
 *
 * @public
 */
declare const identity: <T>(val: T) => T;
/**
 * Return the `onTrue` or the `onFalse` value depending upon the result of the condition `val`.
 *
 * @param val - A predicate value
 * @param onTrue - The `val` evaluates to a truthy value
 * @param onFalse - The `val` evaluates to a falsy value
 * @returns The result of `!!val` ? `onTrue` : `onFalse` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 *
 * @example
 * ```ts
 * ifElse(true, 1, 0) // 1
 * ifElse(false, 1, 0) // 0
 * ifElse(undefined, 1, 0) // 0
 * ifElse(() => true, () => 1, () => 0) // 1
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link ifElseFn}
 *
 * @public
 */
declare const ifElse: <V, T, F>(val: V | AnyFn<any, V>, onTrue: T | AnyFn<any, T>, onFalse: F | AnyFn<any, F>) => V extends FalsyLike ? F : V extends true ? T : T | F;
/**
 * Creates a function that will process either the `onTrue` or the `onFalse` function depending upon the result of the condition predicate.
 *
 * @param condition - A predicate function
 * @param onTrue - Any value or A function to invoke when the `condition` evaluates to a truthy value
 * @param onFalse - Any value or A function to invoke when the `condition` evaluates to a falsy value
 * @returns A new function that will process either the `onTrue` or the `onFalse` function depending upon the result of the `condition` predicate
 *
 * @example
 * ```ts
 * ifElseFn((x: number) => x > 10, 'big', 'small')(20) // 'big'
 * const fn = ifElseFn((x: number) => x > 10, (x) => x + 1, (x) => x - 1)
 * fn(11) // 12
 * fn(9) // 8
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link ifElse}
 *
 * @public
 */
declare const ifElseFn: <V, R, T, F>(condition: (val: V) => R, onTrue: T | ((val: V) => T), onFalse: F | ((val: V) => F)) => (val: V) => R extends true ? T : R extends FalsyLike ? F : T | F;
/**
 * Increments its argument.
 *
 * @param val - Input `number` or `bigint`
 * @returns Incremented `val`
 *
 * @example
 * ```ts
 * inc(100) // 101
 * inc(10n) // 11n
 * ```
 *
 * @see Related to {@link dec}
 *
 * @public
 */
declare const inc: {
    (val: number): number;
    (val: bigint): bigint;
};
/**
 * Checks if value is in collection.
 *
 * @param collection - The collection to inspect
 * @param val - The value to search for
 * @returns The result of `collection.includes(val)`
 *
 * @example
 * ```ts
 * includes('hello', 'lo') // true
 * includes([1, 2, 3], 3) // true
 * ```
 *
 * @category `String` `Array`
 *
 * @public
 */
declare const includes: ((collection: string | unknown[], val: unknown) => boolean) & ((collection: string | unknown[]) => (val: unknown) => boolean);
/**
 * Whatever argument is `Array` or not.
 *
 * @param val - Input any value
 * @returns The result of `Array.isArray(val)`
 *
 * @example
 * ```ts
 * isArray([]) // true
 * isArray(['hello', 'world']) // true
 * isArray({}) // false
 * ```
 *
 * @public
 */
declare const isArray: (val: unknown) => val is any[];
/**
 * Whatever argument is type of `bigint` or not.
 *
 * @param val - input any value
 * @returns The result of `typeof val === 'bigint'`
 *
 * @example
 * ```ts
 * isBigint(1n) // true
 * isBigint(1000) // false
 * ```
 *
 * @public
 */
declare const isBigint: (val: unknown) => val is bigint;
/**
 * Whatever argument is type of `boolean` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'boolean'`
 *
 * @example
 * ```ts
 * isBoolean(true) // true
 * isBoolean('hello') // false
 * ```
 *
 * @public
 */
declare const isBoolean: (val: unknown) => val is boolean;
/**
 * Returns `true` if the given value is its type's empty value; otherwise `false`.
 *
 * @param val - Input any value
 * @returns The result of empty or not
 *
 * @remarks
 * The definition of Empty
 * - `''`
 * - `{}`
 * - `[]`
 *
 * @example
 * ```ts
 * isEmpty('') // true
 * isEmpty({}) // true
 * isEmpty([]) // true
 *
 * isEmpty('hello world') // false
 * isEmpty(1000) // false
 * ```
 *
 * @public
 */
declare const isEmpty: (val: unknown) => val is Empty;
/**
 * Whatever argument is type of `function` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'function'`
 *
 * @example
 * ```ts
 * isFunction(function) // true
 * isFunction('hello') // false
 * ```
 *
 * @public
 */
declare const isFunction: (val: unknown) => val is AnyFn<any, unknown>;
/**
 * Whatever argument is JSON Object or not.
 *
 * @param val - Input any value
 * @returns if `val` is JSON Object `true` otherwise; `false`
 *
 * @example
 * ```ts
 * isJSONObject({ hoge: 'huga'}) // true
 * isJSONObject(Object()) // true
 * isJSONObject(new Object()) // true
 *
 * isJSONObject([]) // false
 * isJSONObject(new Set()) // false
 * ```
 *
 * @public
 */
declare const isJSONObject: (val: unknown) => val is Record<PropertyKey, unknown>;
/**
 * Whatever argument length is `0` or not.
 *
 * @param val - Input any value
 * @returns The result of `!val.length` (if not have `length` property, `false`)
 *
 * @example
 * ```ts
 * isLength0([]) // true
 * isLength0([]) // true
 * isLength0('hello') // false
 * isLength0(undefined) // false
 * ```
 *
 * @category `Array` `String`
 *
 * @public
 */
declare const isLength0: (val: unknown) => val is 0;
/**
 * Whatever argument is `NaN` or not.
 *
 * @param val - Input any value
 * @returns The result of `Number.isNaN(val)`
 *
 * @remarks
 * `NaN` is primitive `number`.
 *
 * @example
 * ```ts
 * isNaN(NaN) // true
 * isNaN(100) // false
 * ```
 *
 * @public
 *
 */
declare const isNaN: (val: unknown) => val is number;
/**
 * Whatever argument is type of `undefined` or `null`.
 *
 * @param val - Input any value
 * @returns The result of type of `val` is undefined or null
 *
 * @example
 * ```ts
 * isNumber(0) // true
 * isNumber('hello') // false
 * ```
 *
 * @public
 *
 * @deprecated
 * This is typo. It will rename to `isNil` next major release.
 *
 */
declare const isNill: (val: unknown) => val is null | undefined;
/**
 * Whatever argument is type of `object` or not.
 *
 * @param val - Input any value
 * @returns The result of object or not
 *
 * @remarks
 * Definition of Object
 *
 * Not Primitive
 *
 * @remarks
 * Definition of Primitive
 * - `string`
 * - `number`
 * - `bigint`
 * - `boolean`
 * - `symbol`
 * - `undefined`
 * - `null`
 *
 *
 * @example
 * ```ts
 * isObject([]) // true
 * isObject('hello') // false
 * ```
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/ban-types
declare const isObject: (val: unknown) => val is Record<string, unknown>;
/**
 * Whatever argument is type of `string` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'string'`
 *
 * @example
 * ```ts
 * isString('hello world') // true
 * isString(1000) // false
 * ```
 *
 * @public
 */
declare const isString: (val: unknown) => val is string;
/**
 * Whatever argument is type of `symbol` or not.
 *
 * @param val - Input any value
 * @returns The result of `typeof val === 'symbol'`
 *
 * @example
 * ```ts
 * isSymbol(Symbol('hello')) // true
 * isSymbol('hello') // false
 * ```
 *
 * @public
 */
declare const isSymbol: (val: unknown) => val is symbol;
/**
 * Whatever argument is `primitive` or not.
 *
 * @param val - Input any value
 * @returns The result of primitive or not
 *
 * @remarks
 * Definition of Primitive
 * - `string`
 * - `number`
 * - `bigint`
 * - `boolean`
 * - `symbol`
 * - `undefined`
 * - `null`
 *
 * @example
 * ```ts
 * isPrimitive(true) // true
 * isPrimitive([]) // false
 * ```
 *
 * @public
 */
declare const isPrimitive: (val: unknown) => val is Primitive;
/**
 * K combinator. Returns a function that always returns the given value.
 *
 * @param val - The value to wrap in a function
 * @returns Function wrapped `val`
 *
 * @example
 * ```ts
 * const k = K('k')
 * k() // 'k'
 * ```
 *
 * @public
 */
declare const K: <T extends unknown>(val: T) => () => T;
/**
 * Returns the names of the enumerable string properties and methods of an object.
 *
 * @param val - `Object` that contains the properties and methods
 * @returns The result of `Object.keys(val)`
 *
 * @remarks
 * The order of the output array is not guaranteed to be consistent across different JS platforms.
 *
 * @example
 * ```ts
 * keys({}) // []
 * keys({ 'a': 'b' }) // ['a']
 * keys({ 0: 'hello', 1: 'world' }) // ['0', '1']
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link values} {@link entries}
 *
 * @public
 */
declare const keys$0: <T extends PropertyKey>(val: Record<T, unknown>) => string[];
/**
 * Infer the last types.
 *
 * @typeParam T - `string` or any `array`
 *
 * @example
 * ```ts
 * // String
 * Last<string> // string
 * Last<''> // ''
 * Last<'hello'> // 'o'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * Last<[] | never[] | readonly [] | readonly never[]> // undefined
 * Last<['hello', 'world']> // 'world'
 * Last<string | number[]> // string | number
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link First}
 *
 * @public
 */
type Last<T extends string | readonly unknown[]> = T extends "" ? "" : T extends string ? String2Array<T> extends [
] ? string : [
    never,
    ...String2Array<T>
][String2Array<T>["length"]] : T extends never[] | readonly never[] ? undefined : T extends unknown[] | readonly unknown[] ? [
    never,
    ...T
][T["length"]] : T extends string ? string : never;
/**
 * Returns the last element of the given list or string.
 *
 * @param val - `string` or any `array` object
 * @returns The last element of the `val`
 *
 * @example
 * ```ts
 * // String
 * last('hello') // 'o'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * last('hello', 'new', 'world') // 'world'
 * last([]) // undefined
 * last(['one', 2, 3, 4]) // 4
 * ```
 *
 * @see Related to {@link first}
 *
 * @public
 */
declare const last: <T extends string | readonly unknown[]>(val: T) => Last<T>;
/**
 * Returns length property.
 *
 * @param val - Value with length property
 * @returns The result of `val.length`
 *
 * @example
 * ```ts
 * length('hello') // 5
 * length(['hello', 'world', 1]) // 3
 * length({length: 5, text: 'hello'}) // 5
 * ```
 *
 * @public
 */
declare const length: <T extends {
    length: number;
}>(val: T) => T["length"];
/**
 * Return lowercase string.
 *
 * @param val - Input string value
 * @returns Lowercase string
 *
 * @example
 * ```ts
 * toLower('Hello') // hello
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link upperCase}
 *
 * @public
 */
declare const lowerCase: <T extends string>(val: T) => Lowercase<T>;
/**
 * Returns `true` if the first argument is less than the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a < b`
 *
 * @example
 * ```ts
 * // Number
 * lt(1, 2) // true
 * lt(2, 2) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * lt(1n, 2n) // true
 * lt(2n, 2n) // false
 * ```
 *
 * @example
 * ```ts
 * // String
 * lt('a', 'z') // true
 * lt('a', 'a') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * lt(false, true) // true
 * lt(true, true) // false
 * lt(false, false) // false
 * lt(true, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * lt(new Date('1999/12/31'), new Date('2000/1/1')) // true
 * lt(new Date('2000/1/1'), new Date('2000/1/1')) // false
 * lt(new Date('2000/1/2'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link lte} {@link gt} {@link gte}
 *
 * @public
 */
declare const lt: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Returns `true` if the first argument is less than or equal to the second; otherwise `false`.
 *
 * @param a - The first input value
 * @param b - The second input value
 * @returns The result of `a <= b`
 *
 * @example
 * ```ts
 * // Number
 * lte(1, 2) // true
 * lte(2, 2) // true
 * lte(2, 1) // false
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * lte(1n, 2n) // true
 * lte(2n, 2n) // true
 * lte(2n, 1n) // true
 * ```
 *
 * @example
 * ```ts
 * // String
 * lte('a', 'z') // true
 * lte('a', 'a') // true
 * lte('z', 'a') // false
 * ```
 *
 * @example
 * ```ts
 * // Boolean
 * lte(true, true) // true
 * lte(false, false) // true
 * lte(false, true) // true
 * lte(true, false) // false
 * ```
 *
 * @example
 * ```ts
 * // Date
 * lte(new Date('2000/1/1'), new Date('2000/1/1')) // true
 * lte(new Date('1999/12/31'), new Date('2000/1/1')) // true
 * lte(new Date('2000/1/2'), new Date('2000/1/1')) // false
 * ```
 *
 * @see Related to {@link lt} {@link gt} {@link gte}
 *
 * @public
 */
declare const lte: <T extends Ord>(a: T, b: T) => boolean;
/**
 * Infer `Array.map` types
 *
 * @typeParam T - Return types of function
 * @typeParam U - Input any array
 * @returns Mapped array types
 *
 * @example
 * ```ts
 * MapArray<void, any[]> // undefined[]
 * MapArray<1, any[]> // 1[]
 * MapArray<1, []> // []
 * ```
 *
 * @category `Array`
 *
 * @internal
 */
type MapArray<T, U> = U extends readonly [
] | readonly never[] ? [
] : T extends void ? undefined[] : T[];
/**
 * Infer object applied return value to value
 *
 * @typeParam T - Return types of function
 * @typeParam U - Input any object
 * @returns The result of `{[k in keyof U]: T extends void ? undefined : T }`
 *
 * @example
 * ```ts
 * MapObject<void, {}> // {}
 * MapObject<void, { '': '' }> // { '': undefined }
 * MapObject<number, { hoge: 'huga', 1: 2 }> // { hoge: number, 1: number }
 * ```
 *
 * @category `Object`
 *
 * @internal
 */
type MapObject<T, U extends {
    [k: string]: unknown;
}> = {
    [k in keyof U]: T extends void ? undefined : T;
};
/**
 * Takes a function, applies the function to each, and returns a result of the same shape.
 *
 * @param fn - The function to be called on every element of the input list.
 * @param list - The list to be iterated over.
 * @returns The result of `list.map(fn)` or object applied function to value
 *
 * @example
 * ```ts
 * const triple = (val: number):number => val * 3
 * map(triple, [1, 2, 3]) // [3, 6, 9]
 * map(triple, { tom: 1, john: 2, bob: 3 }) // { tom: 3, john: 6, bob: 9}
 * ```
 *
 * @category `Array` `Object`
 *
 * @public
 */
declare const map: {
    <T extends readonly unknown[], U>(fn: (value: T[number], index: number, list: T) => U, list: T): MapArray<U, T>;
    <T extends {
        [k: string]: unknown;
    }, U>(fn: (val: T[keyof T], prop: keyof T, list: T) => U, list: T): MapObject<U, T>;
};
// re-export
/**
 * Multiplies first argument and second argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a * b`
 *
 * @example
 * ```ts
 * // Basic
 * multiply(2, 3) // 6
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * multiply(2n, 3n) // 6n
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const double = multiply(2)
 * double(4) // 8
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link subtract} {@link divide}
 *
 * @public
 */
declare const multiply: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
};
/**
 * Returns the `!` of its argument.
 *
 * @param val - Input any value
 * @returns The result of `!val`
 *
 * @remarks
 * The Definition of Falsy
 * - `''`
 * - `false`
 * - `0`
 * - `NaN`
 * - `undefined`
 * - `null`
 *
 * @example
 * ```ts
 * N('') // true
 * N(false) // true
 * N(0) // true
 * N(NaN) // true
 * N(undefined) // true
 * N(null) // true
 *
 * N({}) // false
 * N([]) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link NN}
 *
 * @public
 */
declare const N: <T>(val: T) => T extends FalsyLike ? true : boolean;
/**
 * Abbreviation for Not Not. Returns the `!!` of its argument.
 *
 * @param val - Input any value
 * @returns The result of `!!val`
 *
 * @remarks
 * The Definition of Falsy
 * - `''`
 * - `false`
 * - `0`
 * - `NaN`
 * - `undefined`
 * - `null`
 *
 * @example
 * ```ts
 * NN('') // false
 * NN(false) // false
 * NN(0) // false
 * NN(NaN) // false
 * NN(undefined) // false
 * NN(null) // false
 *
 * NN({}) // true
 * NN([]) // true
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link N}
 *
 * @public
 */
declare const NN: <T>(val: T) => T extends FalsyLike ? false : boolean;
/**
 * Returns the function as is with return value `!`.
 *
 * @param val - Input any `function`
 * @returns The result is function what return value with `!`
 *
 * @example
 * ```ts
 * not(() => true)() // false
 * const gt10 = (val: number) => val > 10
 * not(gt10)(11) // false
 * ```
 *
 * @public
 */
declare const not: <T extends AnyFn<any, unknown>>(fn: T) => (...val: Parameters<T>) => boolean;
/**
 * Returns true if one or both of its arguments are true; otherwise false.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!!a || !!bb` (if argument is function, return value)
 *
 * @remarks
 * If you pass a function as an argument, return value will evaluate.
 
 * @example
 * ```ts
 * or(true, true) // true
 * or(false, true) // true
 * or(true, false) // true
 * or(false, false) // false
 *
 * or(() => 0, () => 1) // true
 * or(() => 0, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link and} {@link xor}
 *
 * @public
 */
declare const or: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? U extends FalsyLike ? false : boolean : boolean;
/**
 * Performs left-to-right function composition.
 *
 * @param functions - Multi any functions
 * @returns A `function` what argument is `function[0]` argument
 *
 * @remarks
 * The first argument may have any arity; the remaining arguments must be unary.
 *
 * @example
 * ```ts
 * const fn = pipe(add , inc)
 * fn(1, 1) // 3
 * ```
 *
 * @public
 */
declare const pipe: Pipe;
type Pipe = {
    <F1 extends AnyFn>(fn1: F1): (...initialArg: Parameters<F1>) => ReturnType<F1>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>>(...fn1: [
        F1,
        F2
    ]): (...initialArg: Parameters<F1>) => ReturnType<F2>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>>(...fn1: [
        F1,
        F2,
        F3
    ]): (...initialArg: Parameters<F1>) => ReturnType<F3>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>>(...fn1: [
        F1,
        F2,
        F3,
        F4
    ]): (...initialArg: Parameters<F1>) => ReturnType<F4>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5
    ]): (...initialArg: Parameters<F1>) => ReturnType<F5>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6
    ]): (...initialArg: Parameters<F1>) => ReturnType<F6>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7
    ]): (...initialArg: Parameters<F1>) => ReturnType<F7>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8
    ]): (...initialArg: Parameters<F1>) => ReturnType<F8>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9
    ]): (...initialArg: Parameters<F1>) => ReturnType<F9>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10
    ]): (...initialArg: Parameters<F1>) => ReturnType<F10>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11
    ]): (...initialArg: Parameters<F1>) => ReturnType<F11>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12
    ]): (...initialArg: Parameters<F1>) => ReturnType<F12>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13
    ]): (...initialArg: Parameters<F1>) => ReturnType<F13>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14
    ]): (...initialArg: Parameters<F1>) => ReturnType<F14>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15
    ]): (...initialArg: Parameters<F1>) => ReturnType<F15>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>, F16 extends Arity1Fn<ReturnType<F15>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16
    ]): (...initialArg: Parameters<F1>) => ReturnType<F16>;
    <F1 extends AnyFn, F2 extends Arity1Fn<ReturnType<F1>>, F3 extends Arity1Fn<ReturnType<F2>>, F4 extends Arity1Fn<ReturnType<F3>>, F5 extends Arity1Fn<ReturnType<F4>>, F6 extends Arity1Fn<ReturnType<F5>>, F7 extends Arity1Fn<ReturnType<F6>>, F8 extends Arity1Fn<ReturnType<F7>>, F9 extends Arity1Fn<ReturnType<F8>>, F10 extends Arity1Fn<ReturnType<F9>>, F11 extends Arity1Fn<ReturnType<F10>>, F12 extends Arity1Fn<ReturnType<F11>>, F13 extends Arity1Fn<ReturnType<F12>>, F14 extends Arity1Fn<ReturnType<F13>>, F15 extends Arity1Fn<ReturnType<F14>>, F16 extends Arity1Fn<ReturnType<F15>>, F17 extends Arity1Fn<ReturnType<F16>>>(...fn1: [
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16,
        F17
    ]): (...initialArg: Parameters<F1>) => ReturnType<F17>;
};
/**
 * Returns a new list with the given value at the front, followed by the contents of the list.
 *
 * @param val - The value to add to the front of the new list
 * @param list - The list of elements to add a new item to
 * @returns The result of `[val, ...list]`
 *
 * @example
 * ```ts
 * prepend('Tom', ['hello']) // ['Tom', 'hello']
 * prepend('Tom', []) // ['Tom']
 * prepend(['Tom'], ['hello', 'world']) // [['Tom'], 'hello', 'world']
 * ```
 *
 * @category `Array`
 *
 * @see Related to {@link append}
 *
 * @public
 */
declare const prepend: <T, U>(val: T, list: U[]) => (T | U)[];
/**
 * Multiplies together all the elements of a list.
 *
 * @param val - list An array of numbers
 * @returns The product of all the numbers in the list
 *
 * @example
 * ```ts
 * product([1, 2, 3, 4, 5]) // 120
 * product([1n, 2n, 3n, 4n, 5n]) //120n
 * product([]) // 0
 * ```
 *
 * @category `Math`
 *
 * @public
 */
declare const product: {
    (val: [
    ]): 0;
    (val: number[]): number;
    (val: bigint[]): bigint;
};
/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 *
 * @param val - Input property key
 * @param obj - The object to query
 * @returns The result of safety `obj[val]` or `obj[val[0]][val[1]][val[...x]]`
 *
 * @example
 * ```ts
 * props('x', { x: 'hello' }) // 'hello'
 * props(1, { 1: 100 }) // 100
 * props('x', {}) // undefined
 * ```
 *
 * @category `Object`
 *
 * @see Related to {@link has}
 *
 * @public
 */
declare const props: <T extends string | number, U extends Record<PropertyKey, unknown>>(val: T, obj: U) => U extends Record<T, unknown> ? U[T] : undefined;
/**
 * Infer the replacement value.
 *
 * @typeParam T - Original string
 * @typeParam From - Holds the pattern string that need to replace
 * @typeParam To - Holds the replacement string
 *
 * @example
 * ```ts
 * Replace<'hello Tom', 'Tom', 'Bob'> // 'hello Bob'
 * Replace<'hogehoge', 'hoge', 'fuga'> // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link ReplaceAll}
 *
 * @public
 */
type Replace<T extends string, From extends string, To extends string> = From extends "" | To ? T : T extends `${infer L}${From}${infer R}` ? `${L}${To}${R}` : T;
/**
 * Replaces matches for `from` in string with `to`.
 *
 * @param from - Holds the pattern string that need to replace
 * @param to - Holds the replacement string
 * @param val - Original string
 * @returns The result of `val.replace(from, to)`
 *
 * @example
 * ```ts
 * replace('hello Tom', 'Tom', 'Bob') // 'hello Bob'
 * replace('hogehoge', 'hoge', 'fuga') // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link replaceAll}
 *
 * @public
 */
declare const replace: <From extends string, To extends string, T extends string>(from: From, to: To, val: T) => Replace<T, From, To>;
/**
 * Infer the all replacement value.
 *
 * @typeParam T - Original string
 * @typeParam From - Holds the pattern string that need to replace
 * @typeParam To - Holds the replacement string
 *
 * @example
 * ```ts
 * ReplaceAll<'hello Tom', 'Tom', 'Bob'> // 'hello Bob'
 * ReplaceAll<'hogehoge', 'hoge', 'fuga'> // 'fugafuga'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link Replace}
 *
 * @public
 */
type ReplaceAll<T extends string, From extends string, To extends string> = From extends "" | To ? T : T extends `${infer L}${From}${infer R}` ? `${L}${ReplaceAll<`${To}${R}`, From, To>}` : T;
/**
 * Replaces all matches for `from` in string with `to`.
 *
 * @param from - Holds the pattern string that need to replace
 * @param to - Holds the replacement string
 * @param val - Original string
 * @returns The result of `val.replaceAll(from, to)`
 *
 * @example
 * ```ts
 * replaceAll('hello Tom', 'Tom', 'Bob') // 'hello Bob'
 * replaceAll('hogehoge', 'hoge', 'fuga') // 'fugafuga'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link replace}
 *
 * @public
 */
declare const replaceAll: <From extends string, To extends string, T extends string>(from: From, to: To, val: T) => ReplaceAll<T, From, To>;
/**
 * Returns a new list or string with the elements or characters in reverse order.
 *
 * @param val - list or string characters
 * @returns New list or string characters in reverse order
 *
 * @example
 * ```ts
 * // String
 * reverse('hello') // 'olleh'
 * ```
 *
 * @example
 * ```ts
 * // Any Array
 * reverse(['hello', 'new', 'world']) // ['world', 'new', 'hello']
 * reverse([0, {}, []]) // [[], {}, 0]
 * ```
 *
 * @category `Array`
 *
 * @public
 */
declare const reverse: {
    (val: string): string;
    (val: ""): "";
    <T extends [
    ]>(val: T): [
    ];
    <T extends unknown[]>(val: T): T;
};
/**
 * Returns the elements of the given string or array from `from` to `to`.
 *
 * @param from - The start index
 * @param to - The end index
 * @param val - `String` or `Array`
 * @returns The result of `val.slice(from, to)`
 *
 * @example
 * ```ts
 * // String
 * slice(6, 11 ,'hello world') // 'world'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * slice(1, 2 ,[1, 2, 3, 4]) // [2]
 * ```
 *
 * @category `String` `Array`
 *
 * @public
 */
declare const slice: <T extends string | readonly unknown[]>(from: number, to: number, val: T) => T;
type StartsWith<T extends string | undefined = undefined> = T extends undefined ? (target: string) => ReturnType<string["startsWith"]> : ReturnType<string["startsWith"]>;
/**
 * Checks if a string starts with the provided substring.
 *
 * @param val - search string
 * @param target - target string
 * @returns The result of `target.startsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * startsWith('hello', 'hello world') // true
 * startsWith('good', 'hello world') // false
 * ```
 *
 * @example
 * ```ts
 * // Curry
 * const startWithSlash = startsWith('/')
 * startWithSlash('/path/to') // true
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link endsWith}
 *
 * @public
 */
declare const startsWith: <T extends string, U extends string | undefined = undefined>(val: T, target?: U | undefined) => StartsWith<U>;
// re-export
/**
 * Subtracts its second argument from its first argument.
 *
 * @param a - The first input number
 * @param b - The second input number
 * @returns The result of `a - b`
 *
 * @remarks
 * Since subtraction is not idempotent, there are two ways to curry.
 *
 * @example
 * ```ts
 * // Number
 * subtract(2, 1) // 1
 * ```
 *
 * @example
 * ```ts
 * // Bigint
 * subtract(3n, 2n) //1n
 * ```
 *
 * @example
 * ```ts
 * // First argument curry
 * const from5Minus = subtract(5)
 * from5Minus(10) // -5
 * ```
 *
 * @example
 * ```ts
 * // Second argument curry
 * import { _ } from 'fonction'
 * const minus5 = (_, 5)
 * minus5(20) // 15
 * ```
 *
 * @category `Math`
 *
 * @see Related to {@link add} {@link multiply} {@link divide}
 *
 * @public
 */
declare const subtract: {
    (a: number, b: number): number;
    (a: number): (b: number) => number;
    (a: bigint, b: bigint): bigint;
    (a: bigint): (b: bigint) => bigint;
} & {
    (a: typeof _, b: number): (a: number) => number;
    (a: typeof _, b: bigint): (a: bigint) => bigint;
};
/**
 * Adds together all the elements of a list.
 *
 * @param val - list An array of numbers
 * @returns The sum of all the numbers in the list
 *
 * @example
 * ```ts
 * sum([1, 2, 3, 4, 5]) // 15
 * sum([1n, 2n, 3n, 4n, 5n]) // 15n
 * sum([]) // 0
 * ```
 *
 * @category `Math`
 *
 * @public
 */
declare const sum: {
    (val: [
    ]): 0;
    (val: number[]): number;
    (val: bigint[]): bigint;
};
/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @returns `True`
 *
 * @example
 * ```ts
 * T() // true
 * T(1, 'hello', 'world') // true
 * ```
 *
 * @see Related to {@link F}
 *
 * @public
 */
declare const T: AnyFn<unknown, true>;
/**
 * Returns all but the first element of the given list or string.
 *
 * @param val - string or any array object
 * @returns The result of `val.slice(1, Infinity)`
 *
 * @example
 * ```ts
 * // String
 * tail('hello') // 'ello'
 * tail('h') // ''
 * tail('') // ''
 * ```
 *
 * @example
 * ```ts
 * tail([1, 2, 3]) // [2, 3]
 * tail(['hello', 'world']) // ['world']
 * tail(['hello']) // []
 * tail([]) // []
 * ```
 *
 * @category `Array` `String`
 *
 * @see Related to {@link head}
 *
 * @public
 */
declare const tail: {
    (val: string): string;
    <T extends unknown[]>(val: T): T;
};
/**
 * Return a slice of string or array with `n` elements taken from the beginning.
 *
 * @param howMany - The number of elements to take
 * @param val - `String` or `Array` to query
 * @returns The slice of array
 *
 * @example
 * ```ts
 * // String
 * take(3, 'hello') // 'hel'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * take(3, [1, 2, 3, 4]) // [1, 2, 3]
 * ```
 *
 * @category `String` `Array`
 *
 * @see Related to {@link slice} {@link takeLast}
 *
 * @public
 */
declare const take: <T extends string | readonly unknown[]>(howMany: number, val: T) => T;
/**
 * Return a slice of string or array with `n` elements taken from the end.
 *
 * @param howMany - The number of elements to take
 * @param val - `String` or `Array` to query
 * @returns The slice of array
 *
 * @example
 * ```ts
 * // String
 * takeLast(3, 'hello') // 'llo'
 * ```
 *
 * @example
 * ```ts
 * // Array
 * takeLast(3, [1, 2, 3, 4]) // [2, 3, 4]
 * ```
 *
 * @category `String` `Array`
 *
 * @see Related to {@link slice} {@link take}
 *
 * @public
 */
declare const takeLast: <T extends string | readonly unknown[]>(howMany: number, val: T) => T;
/**
 * Runs the given function with the supplied value, then returns the value.
 *
 * @param fn - The function to call with `val`. The return value of fn will be thrown away.
 * @returns The result of `(val) => fn(val)`
 *
 * @example
 * ```ts
 * tap(console.log)('hello') // hello
 * // log: hello
 * ```
 *
 * @public
 */
declare const tap: <T>(fn: Arity1Fn<T, unknown>) => <R extends T>(val: R) => R;
/**
 * whether a given `string` matches a given regular expression.
 *
 * @param regExp - Any Regular expression
 * @param val - Any `string` value
 * @returns The result is `regExp.test(val)`
 *
 * @example
 * ```ts
 * test(new RegExp('^test'), 'testdata') // true
 * test(/xyz$/, 'testxyz') // true
 * ```
 *
 * @category `String`
 *
 * @public
 */
declare const test: ((regExp: RegExp, val: string) => boolean) & ((regExp: RegExp) => (val: string) => boolean);
/**
 * Infer the string with the left ends of trimmed.
 *
 * @returns String left ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimLeft<' \n\thello'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link TrimRight} {@link Trim}
 *
 * @public
 */
type TrimLeft<T extends string> = T extends `${Space}${infer R}` ? TrimLeft<R> : T;
/**
 * Removes space from left ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimLeft()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimLeft('   hello') // 'hello'
 * trimLeft(' \n\thello') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link trimRight} {@link trim}
 *
 * @public
 */
declare const trimLeft: <T extends string>(val: T) => TrimLeft<T>;
/**
 * Infer the string with the right ends of trimmed.
 *
 * @typeParam T - Any string
 * @returns String right ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimRight<'hello \n\t'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link TrimLeft} {@link Trim}
 *
 * @public
 */
type TrimRight<T extends string> = T extends `${infer R}${Space}` ? TrimRight<R> : T;
/**
 * Removes space from right ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimRight()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimRight('hello   ') // 'hello'
 * trimRight('hello \n\t') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link trimLeft} {@link trim}
 *
 * @public
 */
declare const trimRight: <T extends string>(val: T) => TrimRight<T>;
/**
 * Infer the trimmed string.
 *
 * @typeParam T - Any string
 * @returns Trimmed string
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * Trim<'\t\n hello \t\n'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link TrimLeft} {@link TrimRight}
 *
 * @public
 */
type Trim<T extends string> = TrimLeft<TrimRight<T>>;
/**
 * Removes whitespace from both ends of the string.
 *
 * @param val - `string` to trim
 * @returns The result of `val.trim()`
 *
 * @example
 * ```ts
 * trim('   hello   ') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link trimLeft} {@link trimRight}
 *
 * @public
 */
declare const trim: <T extends string>(val: T) => TrimLeft<TrimRight<T>>;
/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned function evaluates the `tryer`; if it does not throw, it simply returns the result. If the `tryer` does throw, the returned function evaluates the catcher function and returns its result.
 *
 * @param tryer - The function that may throw.
 * @param catcher - The function that will be evaluated if tryer throws.
 * @returns - The result of `try { tryer() } catch(e) { catcher(e) }`
 *
 * @example
 * ```ts
 * tryCatch(() => { throw Error('error') }) // Error('error')
 * tryCatch(() => { throw Error('error') }, 0) // 0
 * tryCatch(() => { throw Error('error') }, (e: Error) => e.message ) // 'error'
 * ```
 *
 * @category `Logic`
 *
 * @public
 */
declare const tryCatch: <R, E, P = unknown>(tryer: AnyFn<any, R>, catcher?: E | AnyFn<P, E> | undefined) => R | E;
/**
 * Returns a new `Array` containing only one copy of each element in the original array. `equal` is used to determine equality.
 *
 * @param val - Input any `array`
 * @returns The list of unique items
 *
 * @example
 * ```ts
 * uniq([1, 2, 1, 1]) // [1, 2]
 * uniq([{}, {}, [], []]) // [{}, []]
 * uniq([[1, 2, 3], [1, 2, 3]]) // [[1, 2, 3]]
 * ```
 *
 * @category `Array`
 *
 * @see Related to {@link equal}
 *
 * @public
 */
declare const uniq: <T extends unknown>(val: readonly T[]) => T[];
// Copyright 2021-present the Fonction authors. All rights reserved. MIT license.
/**
 * Return uppercase string.
 *
 * @param val - Input string value
 * @returns Uppercase string
 *
 * @example
 * ```ts
 * toUpper('Hello') // HELLO
 * ```
 *
 * @category `String`
 *
 * @see Related to {@link lowerCase}
 *
 * @public
 */
declare const upperCase: <T extends string>(val: T) => Uppercase<T>;
/**
 * Returns an array of values of the enumerable properties of an object.
 *
 * @param val - `Object` that contains the properties and methods
 * @returns The result of `Object.values(val)`
 *
 * @remarks
 * The order of the output array is not guaranteed to be consistent across different platforms.
 *
 * @example
 * ```ts
 * // Object
 * values({}) // []
 * values({ 'a': 'b' }) // ['b']
 * values({ 0: 'hello', 1: 'world' }) // ['hello', 'world']
 * ```
 *
 * @example
 * ```ts
 * // Array
 * values([]) // []
 * values(['hello', 'world']) // ['hello', 'world']
 * ```
 *
 * @category `Array` `Object`
 *
 * @see Related to {@link keys} {@link entries}
 *
 * @public
 */
declare const values$0: <T extends unknown>(val: Record<PropertyKey, T> | ArrayLike<T>) => T[];
/**
 * Returns true if one of the arguments is truthy and the other is falsy; otherwise false.
 *
 * @param a - The first input any value
 * @param b - The second input any value
 * @returns The result of `!a !== !b` (if argument is function, return value)
 *
 * @example
 * ```ts
 * xor(true, false) // true
 * xor(false, true) // true
 * xor(true, true) // false
 * xor(false, false) // false
 * xor(() => 1, () => 0) // true
 * xor(() => 0, () => 0) // false
 * ```
 *
 * @category `Logic`
 *
 * @see Related to {@link and} {@link or}
 *
 * @public
 */
declare const xor: <T, U>(a: T | AnyFn<any, T>, b: U | AnyFn<any, U>) => T extends FalsyLike ? U extends FalsyLike ? false : boolean : boolean;
//# sourceMappingURL=index.es.d.ts.map

export { AnyFn, Arity1Fn, Empty, F, Falsy, FalsyLike, First, FlattenDeep, K, Last, N, NN, Ord, Primitive, Replace, ReplaceAll, Space, T, Trim, TrimLeft, TrimRight, _, add, advance, and, append, chunk, constructorName, curry, dec, defaultTo, divide, endsWith, entries$0 as entries, equal, first, flattenDeep, gt, gte, has, hasPath, head, identity, ifElse, ifElseFn, inc, includes, isArray, isBigint, isBoolean, isEmpty, isFunction, isJSONObject, isLength0, isNaN, isNil, isNill, isNull, isNumber, isObject, isPrimitive, isString, isSymbol, isUndefined, keys$0 as keys, last, length, lowerCase, lt, lte, map, multiply, not, or, pipe, prepend, product, props, replace, replaceAll, reverse, slice, startsWith, subtract, sum, tail, take, takeLast, tap, test, trim, trimLeft, trimRight, tryCatch, uniq, upperCase, values$0 as values, xor };
