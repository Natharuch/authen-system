{"version":3,"file":"index.cjs.js","sources":["../_is.ts","../_constants.ts","../_utils.ts","../equal.ts"],"sourcesContent":["// Copyright 2021-present the Equal authors. All rights reserved. MIT license.\nimport {\n  and,\n  isArray,\n  isFunction,\n  isJSONObject,\n  isObject,\n  isPrimitive,\n  N,\n} from \"./deps.ts\";\nimport type { AnyFn } from \"./deps.ts\";\n\nconst isTupleFactory = (fn: AnyFn<any, boolean>) =>\n  <T, U extends T>(a: T, b: U): boolean => and(fn(a), () => fn(b));\n\nconst isObjectExcludeJSON = (val: unknown): val is Record<string, unknown> =>\n  and(isObject(val), () => N(isJSONObject(val)));\n\nconst instanceofFactory = (obj: Function) =>\n  <T, U extends T>(a: T, b: U): boolean =>\n    and(a instanceof obj, () => b instanceof obj);\n\nconst isBothArray = isTupleFactory(isArray);\nconst isBothFunction = isTupleFactory(isFunction);\nconst isBothJSONObject = isTupleFactory(isJSONObject);\nconst isBothPrimitive = isTupleFactory(isPrimitive);\nconst isBothObjectExcludeJSON = isTupleFactory(isObjectExcludeJSON);\nconst isBothDate = instanceofFactory(Date);\nconst isBothRegExp = instanceofFactory(RegExp);\nconst isBothError = instanceofFactory(Error);\nconst isBothMap = instanceofFactory(Map);\nconst isBothSet = instanceofFactory(Set);\nconst isBothURL = instanceofFactory(URL);\nconst isBothArrayBuffer = instanceofFactory(ArrayBuffer);\nconst isBothURLSearchParams = instanceofFactory(URLSearchParams);\nconst isBothTypedArray = <T, U extends T>(a: T, b: U): boolean => {\n  return [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    BigInt64Array,\n    BigUint64Array,\n  ]\n    .some((obj) => instanceofFactory(obj)(a, b));\n};\n\nexport {\n  isBothArray,\n  isBothArrayBuffer,\n  isBothDate,\n  isBothError,\n  isBothFunction,\n  isBothJSONObject,\n  isBothMap,\n  isBothObjectExcludeJSON,\n  isBothPrimitive,\n  isBothRegExp,\n  isBothSet,\n  isBothTypedArray,\n  isBothURL,\n  isBothURLSearchParams,\n};\n","// Copyright 2021-present the Equal authors. All rights reserved. MIT license.\nconst { is, getOwnPropertySymbols } = Object;\n\nexport { getOwnPropertySymbols, is };\n","// Copyright 2021-present the Equal authors. All rights reserved. MIT license.\nimport { getOwnPropertySymbols } from \"./_constants.ts\";\n\nconst entriesSymbol = (\n  val: Record<PropertyKey, unknown>,\n): [string, unknown][] => {\n  const symbols = getOwnPropertySymbols(val) as Extract<\n    PropertyKey,\n    \"symbol\"\n  >[];\n  return symbols.map((symbol) => [symbol, val[symbol]]);\n};\n\nconst instanceOf = <T extends Function>(obj: T, val: unknown): val is T =>\n  val instanceof obj;\n\nexport { entriesSymbol, instanceOf };\n","// Copyright 2021-present the Equal authors. All rights reserved. MIT license.\nimport {\n  and,\n  AnyFn,\n  constructorName,\n  entries,\n  has,\n  ifElse,\n  length,\n  N,\n  or,\n  Primitive,\n} from \"./deps.ts\";\nimport {\n  isBothArray,\n  isBothArrayBuffer,\n  isBothDate,\n  isBothError,\n  isBothFunction,\n  isBothJSONObject,\n  isBothMap,\n  isBothObjectExcludeJSON,\n  isBothPrimitive,\n  isBothRegExp,\n  isBothSet,\n  isBothTypedArray,\n  isBothURL,\n  isBothURLSearchParams,\n} from \"./_is.ts\";\nimport { entriesSymbol, instanceOf } from \"./_utils.ts\";\nimport { is } from \"./_constants.ts\";\n\n/**\n * Returns `true` if its arguments are equivalent, otherwise `false`. Handles cyclical data structures.\n *\n * @param a - Any value\n * @param b - Any value\n * @returns Return `true` if the reference memory is the same or the property members and their values are the same\n *\n * @example\n * ```ts\n * equals(-0, 0) // true\n * equals(NaN, NaN) // true\n * equals([[[[]]]], [[[[]]]]) // true\n * equals({ a: { b: [1, 2, 3]}}, { a: { b: [1, 2, 3]}}) // true\n * ```\n *\n * @public\n */\n\nconst equal = <T, U extends T>(a: T, b: U): boolean => {\n  if (!equalConstructorName(a, b)) return false;\n\n  const verdictTable: [\n    AnyFn<unknown, boolean>,\n    AnyFn<any, boolean>,\n  ][] = [\n    [isBothPrimitive, equalPrimitive],\n    [isBothJSONObject, equalJSONObject],\n    [isBothArray, equalArray],\n    [isBothDate, equalDate],\n    [isBothFunction, equalFunction],\n    [isBothRegExp, equalRegExp],\n    [isBothError, equalError],\n    [isBothMap, equalMap],\n    [isBothSet, equalSet],\n    [isBothTypedArray, equalTypedArray],\n    [isBothArrayBuffer, equalArrayBuffer],\n    [isBothURL, equalURL],\n    [isBothURLSearchParams, equalURLSearchParams],\n    [isBothObjectExcludeJSON, equalObjectExcludeJson],\n  ];\n\n  for (const [filter, fn] of verdictTable) {\n    if (filter(a, b)) {\n      return fn(a, b);\n    }\n  }\n  return false;\n};\n\nconst equalConstructorName = <T, U extends T>(a: T, b: U): boolean =>\n  constructorName(a) === constructorName(b);\n\n/**\n * Returns `true` if its primitive arguments are equivalent; otherwise `false`.\n * @param a - Any primitive value\n * @param b - Any primitive value\n * @returns The result of `Object.is(a, b) || a === b`\n *\n * @example\n * ```ts\n * equalPrimitive(NaN, NaN)) // true\n * equalPrimitive(+0, -0)) // true\n * ```\n * @beta\n */\nconst equalPrimitive = <T extends Primitive, U extends T>(\n  a: T,\n  b: U,\n): boolean => or(is(a, b), () => a === b);\n\nconst equalConstructor = <T, U extends T>(\n  obj: Function,\n  a: T,\n  b: U,\n): boolean => and(instanceOf(obj, a), () => instanceOf(obj, b));\n\nconst equalRegExp = <T extends RegExp, U extends T>(a: T, b: U): boolean =>\n  a.toString() === b.toString();\n\n/**\n * Returns `true` if its `Date` arguments are equivalent; otherwise `false`.\n * @param a - Any `Date` object\n * @param b - Any `Date` object\n * @returns The result of `a.getTime() === b.getTime()`\n *\n * @example\n * ```ts\n * equalDate(new Date(0), new Date(0)) // true\n * equalDate(new Date(\"1999/1/1 00:00:01\"), new Date(\"1999/1/1\") // false\n * ```\n * @beta\n */\nconst equalDate = (a: Date, b: Date): boolean =>\n  equalPrimitive(a.getTime(), b.getTime());\n\n/**\n * Returns `true` if its `Error` arguments are equivalent; otherwise `false`.\n * @param a - Any `Error` and its Derived object\n * @param b - Any `Error` and its Derived object\n * @returns `true` if the constructor and the error message are the same;otherwise false\n *\n * @example\n * ```ts\n * equalError(Error('test'), Error('test')) // true\n * equalError(AggregateError([TypeError('test')]), AggregateError([TypeError('test')])) // true\n * equalError(Error('test'), Error('hello')) // false\n * equalError(Error('test'), TypeError('test')) // false\n * ```\n * @beta\n */\nconst equalError = (a: Error, b: Error): boolean => {\n  if (a.message !== b.message) return false;\n  const errorConstructors = [\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n  ];\n  if (\n    errorConstructors.some((constructor) => equalConstructor(constructor, a, b))\n  ) {\n    return true;\n  }\n\n  return ifElse(equalConstructor(AggregateError, a, b), () =>\n    equalArray(\n      (a as Error as AggregateError).errors,\n      (b as Error as AggregateError).errors,\n    ), () => equalConstructorName(a, b));\n};\n\nconst equalFunction = <T extends Function, U extends T>(a: T, b: U): boolean =>\n  a.toString() === b.toString();\n\nconst equalMap = <T extends Map<any, any>, U extends T>(\n  a: T,\n  b: U,\n): boolean => {\n  if (a.size !== b.size) return false;\n\n  return equalKeyValueTupleNoOrder([...a], [...b]);\n};\n\nconst equalSet = <T extends Set<unknown>, U extends T>(\n  a: T,\n  b: U,\n): boolean => equalArray([...a], [...b]);\n\nconst equalKeyValueTuple = <T extends [unknown, unknown], U extends T>(\n  [keyA, valueA]: T,\n  [keyB, valueB]: U,\n): boolean => and(equal(keyA, keyB), () => equal(valueA, valueB));\n\nconst equalKeyValueTupleNoOrder = <T extends [unknown, unknown][], U extends T>(\n  a: T,\n  b: U,\n): boolean => {\n  if (length(a) !== length(b)) return false;\n\n  // TODO: This logic is terrible performance\n  return and(\n    a.every((tupleA) => b.some((tupleB) => equalKeyValueTuple(tupleA, tupleB))),\n    () =>\n      b.every((tupleB) =>\n        a.some((tupleA) => equalKeyValueTuple(tupleA, tupleB))\n      ),\n  );\n};\n\nconst equalJSONObject = <T extends Record<PropertyKey, unknown>, U extends T>(\n  a: T,\n  b: U,\n): boolean => {\n  const entriesA = [...entries(a), ...entriesSymbol(a)];\n  const entriesB = [...entries(b), ...entriesSymbol(b)];\n  const lenA = length(entriesA);\n  const lenB = length(entriesB);\n\n  if (lenA !== lenB) return false;\n\n  return entriesA.every(([key, value]) =>\n    and(has(key, b), () => equal(value, b[key]))\n  );\n};\n\nconst equalObjectExcludeJson = <\n  T extends Object,\n  U extends T,\n>(\n  a: T,\n  b: U,\n): boolean => {\n  if (\n    [Number, String, Boolean].some((obj) => equalConstructor(obj, a, b))\n  ) {\n    return equal(a.valueOf(), b.valueOf());\n  }\n  return false;\n};\n\nconst equalArray = <T extends unknown[], U extends T>(a: T, b: U): boolean => {\n  const lenA = length(a);\n  const lenB = length(b);\n\n  if (and(N(lenA), () => N(lenB))) return true;\n  if (lenA !== lenB) return false;\n\n  return a.every((val, index) => equal(val, b[index]));\n};\n\nconst equalTypedArray = <\n  T extends\n    | Int8Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n    | BigInt64Array\n    | BigUint64Array,\n>(\n  a: T,\n  b: T,\n): boolean => equalArray([...a], [...b]);\n\n/**\n * Returns `true` if its `ArrayBuffer` arguments are equivalent; otherwise `false`.\n * @param a - Any `ArrayBuffer` object\n * @param b - Any `ArrayBuffer` object\n * @returns The result of `a.byteLength === b.byteLength`\n *\n * @example\n * ```ts\n * equalArrayBuffer(new ArrayBuffer(0), new ArrayBuffer(0)) // true\n * equalArrayBuffer(new ArrayBuffer(0), new ArrayBuffer(1)) // false\n * ```\n * @beta\n */\nconst equalArrayBuffer = (\n  a: ArrayBuffer,\n  b: ArrayBuffer,\n): boolean => a.byteLength === b.byteLength;\n\n/**\n * Returns `true` if its `URL` arguments are equivalent; otherwise `false`.\n * @param a - Any `URL` object\n * @param b - Any `URL` object\n * @returns The result of `a.toString() === b.toString()`\n *\n * @example\n * ```ts\n * equalURL(new URL('https://google.com', 'https://google.com')) // true\n * equalURL(new URL('https://google.com', 'https://google.com/')) // true\n * ```\n * @beta\n */\nconst equalURL = (a: URL, b: URL): boolean => a.toString() === b.toString();\nconst equalURLSearchParams = <T extends URLSearchParams, U extends T>(\n  a: T,\n  b: U,\n) => equalKeyValueTupleNoOrder([...a], [...b]);\n\nexport {\n  equal,\n  equalArray,\n  equalArrayBuffer,\n  equalConstructor,\n  equalDate,\n  equalError,\n  equalFunction,\n  equalJSONObject,\n  equalKeyValueTuple,\n  equalKeyValueTupleNoOrder,\n  equalMap,\n  equalObjectExcludeJson,\n  equalPrimitive,\n  equalRegExp,\n  equalSet,\n  equalTypedArray,\n  equalURL,\n  equalURLSearchParams,\n};\n"],"names":["isTupleFactory","fn","a","b","and","instanceofFactory","obj","isBothArray","isArray","isBothFunction","isFunction","isBothJSONObject","isJSONObject","isBothPrimitive","isPrimitive","isBothObjectExcludeJSON","val","isObject","N","isBothDate","Date","isBothRegExp","RegExp","isBothError","Error","isBothMap","Map","isBothSet","Set","isBothURL","URL","isBothArrayBuffer","ArrayBuffer","isBothURLSearchParams","URLSearchParams","isBothTypedArray","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","some","is","getOwnPropertySymbols","Object","entriesSymbol","map","symbol","instanceOf","equal","equalConstructorName","verdictTable","equalPrimitive","equalJSONObject","equalArray","equalDate","equalFunction","equalRegExp","equalError","equalMap","equalSet","equalTypedArray","equalArrayBuffer","equalURL","equalURLSearchParams","equalObjectExcludeJson","filter","constructorName","or","equalConstructor","toString","getTime","message","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","constructor","ifElse","AggregateError","errors","size","equalKeyValueTupleNoOrder","equalKeyValueTuple","keyA","valueA","keyB","valueB","length","every","tupleA","tupleB","entriesA","entries","entriesB","key","value","has","Number","String","Boolean","valueOf","lenA","lenB","index","byteLength"],"mappings":"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"}