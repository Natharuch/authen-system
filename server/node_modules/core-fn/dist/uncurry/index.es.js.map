{"version":3,"file":"index.es.js","sources":["../../uncurry/string/replace.ts","../../uncurry/string/starts_with.ts","../../uncurry/string/ends_with.ts","../../uncurry/string/repeat.ts","../../uncurry/string/match.ts","../../uncurry/string/char_at.ts","../../uncurry/regexp/test.ts","../../uncurry/regexp/exec.ts","../../uncurry/common/includes.ts","../../uncurry/common/map.ts","../../uncurry/common/slice.ts"],"sourcesContent":["// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * Infer the replacement value.\n *\n * @typeParam T - Original string\n * @typeParam From - Holds the pattern string that need to replace or RegExp\n * @typeParam To - Holds the replacement string\n *\n * @example\n * ```ts\n * Replace<'hello Tom', 'Tom', 'Bob'> // 'hello Bob'\n * Replace<'hogehoge', 'hoge', 'fuga'> // 'fugahoge'\n * ```\n *\n * @category `String`\n *\n * @beta\n */\ntype Replace<\n  T extends string,\n  From extends string | RegExp,\n  To extends string,\n> = From extends \"\" | To ? T\n  : From extends string\n    ? T extends `${infer L}${From}${infer R}` ? `${L}${To}${R}`\n    : T\n  : From extends RegExp ? string\n  : never;\n\n/**\n* Replaces matches for `from` in string or RegExp with `to`.\n*\n* @param from - Holds the pattern string that need to replace or RegExp\n* @param to - Holds the replacement string\n* @param val - Original string\n* @returns The result of `val.replace(from, to)`\n*\n* @example\n* ```ts\n* replace('hello Tom', 'Tom', 'Bob') // 'hello Bob'\n* replace('hogehoge', 'hoge', 'fuga') // 'fugahoge'\n* ```\n*\n* @category `String`\n*\n* @beta\n*/\nconst replace = <\n  From extends string | RegExp,\n  To extends string,\n  T extends string,\n>(\n  from: From,\n  to: To,\n  val: T,\n): Replace<T, From, To> => val.replace(from, to) as Replace<T, From, To>;\n\nexport { replace };\nexport type { Replace };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * Checks if a string starts with the provided substring.\n *\n * @param val - search string\n * @param target - target string\n * @returns The result of `target.startsWith(val)`\n *\n * @example\n * ```ts\n * // Basic\n * startsWith('hello', 'hello world') // true\n * startsWith('good', 'hello world') // false\n * ```\n *\n * @category `String`\n *\n * @beta\n */\nconst startsWith = (\n  val: string,\n  target: string,\n): boolean => target.startsWith(val);\n\nexport { startsWith };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * Checks if a string ends with the provided substring.\n * @param val - Search string\n * @param target - Target string\n * @returns The result of `target.endsWith(val)`\n *\n * @example\n * ```ts\n * endsWith('world', 'hello world') // true\n * endsWith('earth', 'hello world') // false\n * ```\n *\n * @category `String`\n *\n * @beta\n */\nconst endsWith = (\n  val: string,\n  target: string,\n): boolean => target.endsWith(val);\n\nexport { endsWith };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\nimport { tryCatch } from \"../../deps.ts\";\n\n/**\n * Returns a String value that is made from count copies appended together. If count is 0,\n * the empty string is returned.\n * @param count - Number of copies to append\n * @param val - Any string\n * @returns The result of `val.repeat(count)`\n *\n * @remarks\n * No exception will be thrown. If `RangeError` is raised, return `''`.\n *\n * @example\n * ```ts\n * repeat(0, 'abc') // ''\n * repeat(2, 'abc') // 'abcabc'\n * ```\n *\n * @example\n * ```ts\n * // RangeError\n * repeat(-1, 'abc') // ''\n * repeat(Infinity, 'abc') // ''\n * ```\n *\n * @category `String`\n *\n * @beta\n */\nconst repeat = (count: number, val: string): string =>\n  tryCatch(() => val.repeat(count), \"\");\n\nexport { repeat };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * Matches a string with a regular expression, and returns an array containing the results of that search.\n * @param matcher - `RegExp` a variable name or string literal containing the regular expression pattern and flags\n * @param val - Any `String`\n * @returns The result of `val.match(matcher)`\n *\n * @example\n * ```ts\n * match(/xyz/, 'vwxyz') // ['xyz']\n * ```\n *\n * @beta\n */\nconst match = (\n  matcher: string | RegExp,\n  val: string,\n): RegExpMatchArray | null => val.match(matcher);\n\nexport { match };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\ntype IsNegative<T extends number | bigint> = `${T}` extends `-${infer _}` ? true\n  : false;\ntype String2Array<T extends string> = T extends \"\" ? []\n  : T extends `${infer F}${infer R}` ? [F, ...String2Array<R>]\n  : string[];\n\n/**\n * @internal\n */\ntype CharAt<T extends number, U extends string> = IsNegative<T> extends true\n  ? \"\"\n  : String2Array<U>[T] extends infer R ? R extends undefined ? \"\" : R\n  : string;\n\n/**\n * Returns the character at the specified index.\n * @param pos - The zero-based index of the desired character\n * @param val - Any `String`\n * @returns The result of `val.charAt(pos)`\n *\n * @remarks\n * Due to the TypeScript recursion limit, the maximum number of valid characters is `23`. If you want to adapt a `string` longer than that, need to cast it to a `string` type.\n *\n * @example\n * ```ts\n * charAt(0, 'hello') // 'h'\n * charAt(4, 'hello') // 'o'\n * charAt(100, 'hello') // ''\n * ```\n *\n * @beta\n */\nconst charAt = <T extends number, U extends string>(\n  pos: T,\n  val: U,\n): CharAt<T, U> => val.charAt(pos) as CharAt<T, U>;\n\nexport { charAt };\nexport type { CharAt };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * whether a given `string` matches a given regular expression.\n *\n * @param regExp - Any Regular expression\n * @param val - Any `string` value\n * @returns The result of `regExp.test(val)`\n *\n * @example\n * ```ts\n * test(new RegExp('^test'), 'testdata') // true\n * test(/xyz$/, 'testxyz') // true\n * ```\n *\n * @category `RegExp`\n *\n * @beta\n */\nconst test = (regExp: RegExp, val: string): boolean => regExp.test(val);\n\nexport { test };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\n\n/**\n * Executes a search on a `string` using a regular expression pattern, and returns an `array` containing the results of that search.\n * @param regExp - Any `RegExp`\n * @param val - Any `String`\n * @returns The result of `regExp.exec(val)`\n *\n * @example\n * ```ts\n * exec(/^test/, 'test-data') // ['test']\n * ```\n *\n * @beta\n */\nconst exec = (regExp: RegExp, val: string) => regExp.exec(val);\n\nexport { exec };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\nimport { TypedArray } from \"../../deps.ts\";\n\n/**\n * Checks if value is in collection.\n *\n * @param val - The value to search for\n * @param collection - The collection to inspect\n * @returns The result of `collection.includes(val)`\n *\n * @example\n * ```ts\n * includes('lo', 'hello') // true\n * includes(3, [1, 2, 3]) // true\n * includes(20, new Uint8Array([10, 20, 30, 40, 50])) // true\n * ```\n *\n * @category `String` `Array`\n *\n * @beta\n */\nconst includes = <T extends string | readonly unknown[] | TypedArray>(\n  val: T extends string ? string : T[number],\n  collection: T,\n): boolean => collection.includes(val as never);\n\nexport { includes };\nexport type { TypedArray };\n","// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.\nimport { TypedArray } from \"../../deps.ts\";\n\n/**\n * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n * @param callbackfn - callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array\n * @param val - Any `Array` or `TypedArray`\n * @returns The result of `val.map(callbackfn)`\n *\n * @example\n * ```ts\n * map(() => 1, [1, 2, 3]) // [1, 1, 1]\n * map((a) => a + 1, new Unit8Array([2, 4, 6])) // Uint8Array(2) [3, 5, 7]\n * ```\n *\n * @beta\n */\nconst map = <T extends TypedArray | readonly unknown[]>(\n  callbackfn: (value: T[number], index: number, array: T) => T[number],\n  val: T,\n): T extends unknown[] ? Exclude<T, TypedArray> : Exclude<T, unknown[]> =>\n  val.map(callbackfn as never) as never;\n\nexport { map };\n","import { TypedArray } from \"../../deps.ts\";\n/**\n * Returns a section of a value.\n * @param start - The index to the beginning of the specified portion\n * @param end - The index to the end of the specified portion\n * @param val - Any `String`, `Array`, `TypedArray`, `ArrayBuffer`, `SharedArrayBuffer` and `Blog`\n * @returns The result of `val.slice(start, end)`\n *\n * @example\n * ```ts\n * slice(0, 2, 'hello') // 'he'\n * slice(1, Infinity, [1, 2, 3]) // [2, 3]\n * ```\n *\n * @beta\n */\nconst slice = <\n  T extends\n    | string\n    | readonly unknown[]\n    | TypedArray\n    | ArrayBuffer\n    | SharedArrayBuffer\n    | Blob,\n>(\n  start: number | undefined,\n  end: number | undefined,\n  val: T,\n): T => val.slice(start ?? 0, end) as T;\n\nexport { slice };\n"],"names":["replace","from","to","val","startsWith","target","endsWith","repeat","count","tryCatch","match","matcher","charAt","pos","test","regExp","exec","includes","collection","map","callbackfn","slice","start","end"],"mappings":";6DAgDMA,EAAU,CAKdC,EACAC,EACAC,IACyBA,EAAIH,QAAQC,EAAMC,GCpCvCE,EAAa,CACjBD,EACAE,IACYA,EAAOD,WAAWD,GCL1BG,EAAW,CACfH,EACAE,IACYA,EAAOC,SAASH,GCSxBI,EAAS,CAACC,EAAeL,IAC7BM,GAAS,IAAMN,EAAII,OAAOC,IAAQ,IChB9BE,EAAQ,CACZC,EACAR,IAC4BA,EAAIO,MAAMC,GCgBlCC,EAAS,CACbC,EACAV,IACiBA,EAAIS,OAAOC,GClBxBC,EAAO,CAACC,EAAgBZ,IAAyBY,EAAOD,KAAKX,GCJ7Da,EAAO,CAACD,EAAgBZ,IAAgBY,EAAOC,KAAKb,GCMpDc,EAAW,CACfd,EACAe,IACYA,EAAWD,SAASd,GCP5BgB,EAAM,CACVC,EACAjB,IAEAA,EAAIgB,IAAIC,GCLJC,EAAQ,CASZC,EACAC,EACApB,IACMA,EAAIkB,MAAMC,MAAAA,EAAAA,EAAS,EAAGC"}