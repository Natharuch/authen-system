import { TypedArray } from "fonction";
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Infer the replacement value.
 *
 * @typeParam T - Original string
 * @typeParam From - Holds the pattern string that need to replace or RegExp
 * @typeParam To - Holds the replacement string
 *
 * @example
 * ```ts
 * Replace<'hello Tom', 'Tom', 'Bob'> // 'hello Bob'
 * Replace<'hogehoge', 'hoge', 'fuga'> // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
type Replace<T extends string, From extends string | RegExp, To extends string> = From extends "" | To ? T : From extends string ? T extends `${infer L}${From}${infer R}` ? `${L}${To}${R}` : T : From extends RegExp ? string : never;
/**
 * Replaces matches for `from` in string or RegExp with `to`.
 *
 * @param from - Holds the pattern string that need to replace or RegExp
 * @param to - Holds the replacement string
 * @param val - Original string
 * @returns The result of `val.replace(from, to)`
 *
 * @example
 * ```ts
 * replace('hello Tom', 'Tom', 'Bob') // 'hello Bob'
 * replace('hogehoge', 'hoge', 'fuga') // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const replace: <From extends string | RegExp, To extends string, T extends string>(from: From, to: To, val: T) => Replace<T, From, To>;
/**
 * Checks if a string starts with the provided substring.
 *
 * @param val - search string
 * @param target - target string
 * @returns The result of `target.startsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * startsWith('hello', 'hello world') // true
 * startsWith('good', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const startsWith: (val: string, target: string) => boolean;
/**
 * Checks if a string ends with the provided substring.
 * @param val - Search string
 * @param target - Target string
 * @returns The result of `target.endsWith(val)`
 *
 * @example
 * ```ts
 * endsWith('world', 'hello world') // true
 * endsWith('earth', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const endsWith: (val: string, target: string) => boolean;
/**
 * Returns a String value that is made from count copies appended together. If count is 0,
 * the empty string is returned.
 * @param count - Number of copies to append
 * @param val - Any string
 * @returns The result of `val.repeat(count)`
 *
 * @remarks
 * No exception will be thrown. If `RangeError` is raised, return `''`.
 *
 * @example
 * ```ts
 * repeat(0, 'abc') // ''
 * repeat(2, 'abc') // 'abcabc'
 * ```
 *
 * @example
 * ```ts
 * // RangeError
 * repeat(-1, 'abc') // ''
 * repeat(Infinity, 'abc') // ''
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const repeat: (count: number, val: string) => string;
/**
 * Matches a string with a regular expression, and returns an array containing the results of that search.
 * @param matcher - `RegExp` a variable name or string literal containing the regular expression pattern and flags
 * @param val - Any `String`
 * @returns The result of `val.match(matcher)`
 *
 * @example
 * ```ts
 * match(/xyz/, 'vwxyz') // ['xyz']
 * ```
 *
 * @beta
 */
declare const match: (matcher: string | RegExp, val: string) => RegExpMatchArray | null;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
type IsNegative<T extends number | bigint> = `${T}` extends `-${infer _}` ? true : false;
type String2Array<T extends string> = T extends "" ? [
] : T extends `${infer F}${infer R}` ? [
    F,
    ...String2Array<R>
] : string[];
/**
 * @internal
 */
type CharAt<T extends number, U extends string> = IsNegative<T> extends true ? "" : String2Array<U>[T] extends infer R ? R extends undefined ? "" : R : string;
/**
 * Returns the character at the specified index.
 * @param pos - The zero-based index of the desired character
 * @param val - Any `String`
 * @returns The result of `val.charAt(pos)`
 *
 * @remarks
 * Due to the TypeScript recursion limit, the maximum number of valid characters is `23`. If you want to adapt a `string` longer than that, need to cast it to a `string` type.
 *
 * @example
 * ```ts
 * charAt(0, 'hello') // 'h'
 * charAt(4, 'hello') // 'o'
 * charAt(100, 'hello') // ''
 * ```
 *
 * @beta
 */
declare const charAt: <T extends number, U extends string>(pos: T, val: U) => CharAt<T, U>;
/**
 * whether a given `string` matches a given regular expression.
 *
 * @param regExp - Any Regular expression
 * @param val - Any `string` value
 * @returns The result of `regExp.test(val)`
 *
 * @example
 * ```ts
 * test(new RegExp('^test'), 'testdata') // true
 * test(/xyz$/, 'testxyz') // true
 * ```
 *
 * @category `RegExp`
 *
 * @beta
 */
declare const test: (regExp: RegExp, val: string) => boolean;
/**
 * Executes a search on a `string` using a regular expression pattern, and returns an `array` containing the results of that search.
 * @param regExp - Any `RegExp`
 * @param val - Any `String`
 * @returns The result of `regExp.exec(val)`
 *
 * @example
 * ```ts
 * exec(/^test/, 'test-data') // ['test']
 * ```
 *
 * @beta
 */
declare const exec: (regExp: RegExp, val: string) => RegExpExecArray | null;
/**
 * Checks if value is in collection.
 *
 * @param val - The value to search for
 * @param collection - The collection to inspect
 * @returns The result of `collection.includes(val)`
 *
 * @example
 * ```ts
 * includes('lo', 'hello') // true
 * includes(3, [1, 2, 3]) // true
 * includes(20, new Uint8Array([10, 20, 30, 40, 50])) // true
 * ```
 *
 * @category `String` `Array`
 *
 * @beta
 */
declare const includes: <T extends string | TypedArray | readonly unknown[]>(val: T extends string ? string : T[number], collection: T) => boolean;
/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 * @param callbackfn - callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array
 * @param val - Any `Array` or `TypedArray`
 * @returns The result of `val.map(callbackfn)`
 *
 * @example
 * ```ts
 * map(() => 1, [1, 2, 3]) // [1, 1, 1]
 * map((a) => a + 1, new Unit8Array([2, 4, 6])) // Uint8Array(2) [3, 5, 7]
 * ```
 *
 * @beta
 */
declare const map: <T extends TypedArray | readonly unknown[]>(callbackfn: (value: T[number], index: number, array: T) => T[number], val: T) => T extends unknown[] ? Exclude<T, TypedArray> : Exclude<T, unknown[]>;
/**
 * Returns a section of a value.
 * @param start - The index to the beginning of the specified portion
 * @param end - The index to the end of the specified portion
 * @param val - Any `String`, `Array`, `TypedArray`, `ArrayBuffer`, `SharedArrayBuffer` and `Blog`
 * @returns The result of `val.slice(start, end)`
 *
 * @example
 * ```ts
 * slice(0, 2, 'hello') // 'he'
 * slice(1, Infinity, [1, 2, 3]) // [2, 3]
 * ```
 *
 * @beta
 */
declare const slice: <T extends string | TypedArray | readonly unknown[] | ArrayBuffer | SharedArrayBuffer | Blob>(start: number | undefined, end: number | undefined, val: T) => T;
export { replace, startsWith, endsWith, repeat, match, charAt, test, exec, includes, map, slice };
//# sourceMappingURL=index.es.d.ts.map