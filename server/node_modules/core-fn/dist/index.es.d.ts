import { Space } from "fonction";
/**
 * Replaces matches for `from` in string or RegExp with `to`.
 *
 * @param from - Holds the pattern string that need to replace or RegExp
 * @param to - Holds the replacement string
 * @param val - Original string
 * @returns The result of `val.replace(from, to)`
 *
 * @example
 * ```ts
 * replace('hello Tom', 'Tom', 'Bob') // 'hello Bob'
 * replace('hogehoge', 'hoge', 'fuga') // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const replace: ((from: string | RegExp, to: string, val: string) => string) & ((from: string | RegExp, to: string) => (val: string) => string) & ((from: string | RegExp) => ((to: string, val: string) => string) & ((to: string) => (val: string) => string));
/**
 * Checks if a string starts with the provided substring.
 *
 * @param val - search string
 * @param target - target string
 * @returns The result of `target.startsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * startsWith('hello', 'hello world') // true
 * startsWith('good', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const startsWith: ((val: string, target: string) => boolean) & ((val: string) => (target: string) => boolean);
/**
 * Checks if a string ends with the provided substring.
 *
 * @param val - Search string
 * @param target - Target string
 * @returns The result of `target.endsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * endsWith('world', 'hello world') // true
 * endsWith('earth', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const endsWith: ((val: string, target: string) => boolean) & ((val: string) => (target: string) => boolean);
/**
 * Infer the string with the left ends of trimmed.
 *
 * @returns String left ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimStart<' \n\thello'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
type TrimStart<T extends string> = T extends `${Space}${infer R}` ? TrimStart<R> : T;
/**
 * Removes the leading white space and line terminator characters from a string.
 *
 * @param val - input string
 * @returns The result of `val.trimStart()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimStart('   hello') // 'hello'
 * trimStart(' \n\thello') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimStart: <T extends string>(val: T) => TrimStart<T>;
/**
 * Infer the string with the right ends of trimmed.
 *
 * @typeParam T - Any string
 * @returns String right ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimEnd<'hello \n\t'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
type TrimEnd<T extends string> = T extends `${infer R}${Space}` ? TrimEnd<R> : T;
/**
 * Removes the trailing white space and line terminator characters from a string.
 *
 * @param val - input string
 * @returns The result of `val.trimEnd()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimEnd('hello   ') // 'hello'
 * trimEnd('hello \n\t') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimEnd: <T extends string>(val: T) => TrimEnd<T>;
/**
 * Removes whitespace from both ends of the string.
 *
 * @param val - `string` to trim
 * @returns The result of `val.trim()`
 *
 * @example
 * ```ts
 * trim('   hello   ') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trim: <T extends string>(val: T) => TrimStart<TrimEnd<T>>;
/**
 * Removes space from left ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimLeft()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimLeft('   hello') // 'hello'
 * trimLeft(' \n\thello') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimLeft: <T extends string>(val: T) => TrimStart<T>;
/**
 * Removes space from right ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimRight()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimRight('hello   ') // 'hello'
 * trimRight('hello \n\t') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimRight: <T extends string>(val: T) => TrimEnd<T>;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Return lowercase string.
 *
 * @param val - Input string value
 * @returns Lowercase string
 *
 * @example
 * ```ts
 * toLowerCase('Hello') // hello
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const toLowerCase: <T extends string>(val: T) => Lowercase<T>;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Return uppercase string.
 *
 * @param val - Input string value
 * @returns Uppercase string
 *
 * @example
 * ```ts
 * toUpperCase('Hello') // HELLO
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const toUpperCase: <T extends string>(val: T) => Uppercase<T>;
/**
 * Returns a String value that is made from count copies appended together. If count is 0,
 * the empty string is returned.
 * @param count - Number of copies to append
 * @param val - Any string
 * @returns The result of `val.repeat(count)`
 *
 * @remarks
 * No exception will be thrown. If `RangeError` is raised, return `''`.
 *
 * @example
 * ```ts
 * repeat(0, 'abc') // ''
 * repeat(2, 'abc') // 'abcabc'
 * ```
 *
 * @example
 * ```ts
 * // RangeError
 * repeat(-1, 'abc') // ''
 * repeat(Infinity, 'abc') // ''
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const repeat: ((count: number, val: string) => string) & ((count: number) => (val: string) => string);
/**
 * Matches a string with a regular expression, and returns an array containing the results of that search.
 * @param matcher - `RegExp` a variable name or string literal containing the regular expression pattern and flags
 * @param val - Any `String`
 * @returns The result of `val.match(matcher)`
 *
 * @example
 * ```ts
 * match(/xyz/, 'vwxyz') // ['xyz']
 * ```
 *
 * @beta
 */
declare const match: ((matcher: string | RegExp, val: string) => RegExpMatchArray | null) & ((matcher: string | RegExp) => (val: string) => RegExpMatchArray | null);
/**
 * Returns the character at the specified index.
 * @param pos - The zero-based index of the desired character
 * @param val - Any `String`
 * @returns The result of `val.charAt(pos)`
 *
 * @example
 * ```ts
 * charAt(0, 'hello') // 'h'
 * charAt(4, 'hello') // 'o'
 * charAt(100, 'hello') // ''
 * ```
 *
 * @beta
 */
declare const charAt: ((pos: number, val: string) => string) & ((pos: number) => (val: string) => string);
/**
 * Returns length property.
 *
 * @param val - Value with length property
 * @returns The result of `val.length`
 *
 * @example
 * ```ts
 * length('hello') // 5
 * length(['hello', 'world', 1]) // 3
 * length({length: 5, text: 'hello'}) // 5
 * ```
 *
 * @beta
 */
declare const length: <T extends {
    length: number;
}>(val: T) => T["length"];
/**
 * Checks if value is in collection.
 *
 * @param val - The value to search for
 * @param collection - The collection to inspect
 * @returns The result of `collection.includes(val)`
 *
 * @example
 * ```ts
 * includes('lo', 'hello') // true
 * includes(3, [1, 2, 3]) // true
 * includes(20, new Uint8Array([10, 20, 30, 40, 50])) // true
 * ```
 *
 * @category `String` `Array`
 *
 * @beta
 */
declare const includes: ((val: unknown, collection: string | readonly unknown[] | import("fonction").TypedArray) => boolean) & ((val: unknown) => (collection: string | readonly unknown[] | import("fonction").TypedArray) => boolean);
/**
 * Calls a defined callback function on each element of an array, and returns an array that contains the results.
 * @param callbackfn - callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array
 * @param val - Any `Array` or `TypedArray`
 * @returns The result of `val.map(callbackfn)`
 *
 * @example
 * ```ts
 * map(() => 1, [1, 2, 3]) // [1, 1, 1]
 * map((a) => a + 1, new Unit8Array([2, 4, 6])) // Uint8Array(2) [3, 5, 7]
 * ```
 *
 * @beta
 */
declare const map: ((callbackfn: (value: unknown, index: number, array: readonly unknown[] | import("fonction").TypedArray) => unknown, val: readonly unknown[] | import("fonction").TypedArray) => readonly unknown[] | import("fonction").TypedArray) & ((callbackfn: (value: unknown, index: number, array: readonly unknown[] | import("fonction").TypedArray) => unknown) => (val: readonly unknown[] | import("fonction").TypedArray) => readonly unknown[] | import("fonction").TypedArray);
/**
 * Returns a section of a value.
 * @param start - The index to the beginning of the specified portion
 * @param end - The index to the end of the specified portion
 * @param val - Any `String`, `Array`, `TypedArray`, `ArrayBuffer`, `SharedArrayBuffer` and `Blog`
 * @returns The result of `val.slice(start, end)`
 *
 * @example
 * ```ts
 * slice(0, 2, 'hello') // 'he'
 * slice(1, Infinity, [1, 2, 3]) // [2, 3]
 * ```
 *
 * @beta
 */
declare const slice: ((start: number | undefined, end: number | undefined, val: string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) => string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) & ((start: number | undefined, end: number | undefined) => (val: string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) => string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) & ((start: number | undefined) => ((end: number | undefined, val: string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) => string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) & ((end: number | undefined) => (val: string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob) => string | readonly unknown[] | import("fonction").TypedArray | ArrayBuffer | SharedArrayBuffer | Blob));
/**
 * whether a given `string` matches a given regular expression.
 *
 * @param regExp - Any Regular expression
 * @param val - Any `string` value
 * @returns The result of `regExp.test(val)`
 *
 * @example
 * ```ts
 * test(new RegExp('^test'), 'testdata') // true
 * test(/xyz$/, 'testxyz') // true
 * ```
 *
 * @category `RegExp`
 *
 * @beta
 */
declare const test: ((regExp: RegExp, val: string) => boolean) & ((regExp: RegExp) => (val: string) => boolean);
/**
 * Executes a search on a `string` using a regular expression pattern, and returns an `array` containing the results of that search.
 * @param regExp - Any `RegExp`
 * @param val - Any `String`
 * @returns The result of `regExp.exec(val)`
 *
 * @example
 * ```ts
 * exec(/^test/, 'test-data') // ['test']
 * ```
 *
 * @beta
 */
declare const exec: ((regExp: RegExp, val: string) => RegExpExecArray | null) & ((regExp: RegExp) => (val: string) => RegExpExecArray | null);
/**
 * Returns a Boolean value indicating the state of the dotAll flag (s) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.dotAll`
 *
 * @example
 * ```ts
 * dotAll(/test/s) // true
 * dotAll(/test/) // false
 * ```
 *
 * @beta
 */
declare const dotAll: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.unicode`
 *
 * @example
 * ```ts
 * dotAll(/test/u) // true
 * dotAll(/test/) // false
 * ```
 *
 * @beta
 */
declare const unicode: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.ignoreCase`
 *
 * @example
 * ```ts
 * ignoreCase(/test/s) // true
 * ignoreCase(/test/) // false
 * ```
 *
 * @beta
 */
declare const ignoreCase: (regExp: RegExp) => boolean;
/**
 * Returns a string indicating the flags of the regular expression in question. This field is read-only. The characters in this string are sequenced and concatenated in the following order:
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.flags`
 *
 * @remarks
 * - "g" for global
 * - "i" for ignoreCase
 * - "m" for multiline
 * - "u" for unicode
 * - "y" for sticky
 *
 * If no flags are set, the value is the empty string.
 *
 * @example
 * ```ts
 * flags(/test/s) // true
 * flags(/test/) // false
 * ```
 *
 * @beta
 */
declare const flags: (regExp: RegExp) => string;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.global`
 *
 * @example
 * ```ts
 * global(/test/g) // true
 * global(/test/) // false
 * ```
 *
 * @beta
 */
declare const global: (regExp: RegExp) => boolean;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.sticky`
 *
 * @example
 * ```ts
 * sticky(/test/y) // true
 * sticky(/test/) // false
 * ```
 *
 * @beta
 */
declare const sticky: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.multiline`
 *
 * @example
 * ```ts
 * multiline(/test/y) // true
 * multiline(/test/) // false
 * ```
 *
 * @beta
 */
declare const multiline: (regExp: RegExp) => boolean;
/**
 * Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.source`
 *
 * @example
 * ```ts
 * source(/test/s) // true
 * source(/test/) // false
 * ```
 *
 * @beta
 */
declare const source: (regExp: RegExp) => string;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns read/write integer property of `RegExp` instances that specifies the index at which to start the next match.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.lastIndex`
 *
 * @example
 * ```ts
 * const re = /t/g;
 * exec(re, "test");
 * lastIndex(re) // 1
 * ```
 *
 * @beta
 */
declare const lastIndex: (regExp: RegExp) => number;
/**
 * Expose the [[Description]] internal slot of a symbol directly.
 * @param val - Any `Symbol`
 * @returns The result of `val.description`
 *
 * @example
 * ```ts
 * description(Symbol()) // undefined
 * description(Symbol('')) // ''
 * description(Symbol('abc')) // 'abc'
 * ```
 *
 * @beta
 */
declare const description: (val: symbol) => symbol["description"];
export { replace, startsWith, endsWith, trim, trimLeft, trimRight, toLowerCase, toUpperCase, repeat, trimEnd, trimStart, match, charAt, length, includes, map, slice, test, exec, dotAll, unicode, ignoreCase, flags, global, sticky, multiline, source, lastIndex, description };
//# sourceMappingURL=index.es.d.ts.map