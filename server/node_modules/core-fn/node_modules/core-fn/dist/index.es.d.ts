import { Space } from "fonction";
/**
 * Replaces matches for `from` in string or RegExp with `to`.
 *
 * @param from - Holds the pattern string that need to replace or RegExp
 * @param to - Holds the replacement string
 * @param val - Original string
 * @returns The result of `val.replace(from, to)`
 *
 * @example
 * ```ts
 * replace('hello Tom', 'Tom', 'Bob') // 'hello Bob'
 * replace('hogehoge', 'hoge', 'fuga') // 'fugahoge'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const replace: ((from: string | RegExp, to: string, val: string) => string) & ((from: string | RegExp, to: string) => (val: string) => string) & ((from: string | RegExp) => ((to: string, val: string) => string) & ((to: string) => (val: string) => string));
/**
 * Checks if a string starts with the provided substring.
 *
 * @param val - search string
 * @param target - target string
 * @returns The result of `target.startsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * startsWith('hello', 'hello world') // true
 * startsWith('good', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const startsWith: ((val: string, target: string) => boolean) & ((val: string) => (target: string) => boolean);
/**
 * Checks if a string ends with the provided substring.
 *
 * @param val - Search string
 * @param target - Target string
 * @returns The result of `target.endsWith(val)`
 *
 * @example
 * ```ts
 * // Basic
 * endsWith('world', 'hello world') // true
 * endsWith('earth', 'hello world') // false
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const endsWith: ((val: string, target: string) => boolean) & ((val: string) => (target: string) => boolean);
/**
 * Infer the string with the left ends of trimmed.
 *
 * @returns String left ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimStart<' \n\thello'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
type TrimStart<T extends string> = T extends `${Space}${infer R}` ? TrimStart<R> : T;
/**
 * Removes the leading white space and line terminator characters from a string.
 *
 * @param val - input string
 * @returns The result of `val.trimStart()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimStart('   hello') // 'hello'
 * trimStart(' \n\thello') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimStart: <T extends string>(val: T) => TrimStart<T>;
/**
 * Infer the string with the right ends of trimmed.
 *
 * @typeParam T - Any string
 * @returns String right ends of trimmed
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * TrimEnd<'hello \n\t'> // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
type TrimEnd<T extends string> = T extends `${infer R}${Space}` ? TrimEnd<R> : T;
/**
 * Removes the trailing white space and line terminator characters from a string.
 *
 * @param val - input string
 * @returns The result of `val.trimEnd()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimEnd('hello   ') // 'hello'
 * trimEnd('hello \n\t') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimEnd: <T extends string>(val: T) => TrimEnd<T>;
/**
 * Removes whitespace from both ends of the string.
 *
 * @param val - `string` to trim
 * @returns The result of `val.trim()`
 *
 * @example
 * ```ts
 * trim('   hello   ') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trim: <T extends string>(val: T) => TrimStart<TrimEnd<T>>;
/**
 * Removes space from left ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimLeft()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimLeft('   hello') // 'hello'
 * trimLeft(' \n\thello') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimLeft: <T extends string>(val: T) => TrimStart<T>;
/**
 * Removes space from right ends of the string.
 *
 * @param val - input string
 * @returns The result of `val.trimRight()`
 *
 * @remarks
 * The definition of space
 * - `''`
 * - `\n`
 * - `\t`
 *
 * @example
 * ```ts
 * trimRight('hello   ') // 'hello'
 * trimRight('hello \n\t') // 'hello'
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const trimRight: <T extends string>(val: T) => TrimEnd<T>;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Return lowercase string.
 *
 * @param val - Input string value
 * @returns Lowercase string
 *
 * @example
 * ```ts
 * toLowerCase('Hello') // hello
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const toLowerCase: <T extends string>(val: T) => Lowercase<T>;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Return uppercase string.
 *
 * @param val - Input string value
 * @returns Uppercase string
 *
 * @example
 * ```ts
 * toUpperCase('Hello') // HELLO
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const toUpperCase: <T extends string>(val: T) => Uppercase<T>;
/**
 * Returns a String value that is made from count copies appended together. If count is 0,
 * the empty string is returned.
 * @param count - Number of copies to append
 * @param val - Any string
 * @returns The result of `val.repeat(count)`
 *
 * @remarks
 * No exception will be thrown. If `RangeError` is raised, return `''`.
 *
 * @example
 * ```ts
 * repeat(0, 'abc') // ''
 * repeat(2, 'abc') // 'abcabc'
 * ```
 *
 * @example
 * ```ts
 * // RangeError
 * repeat(-1, 'abc') // ''
 * repeat(Infinity, 'abc') // ''
 * ```
 *
 * @category `String`
 *
 * @beta
 */
declare const repeat: ((count: number, val: string) => string) & ((count: number) => (val: string) => string);
/**
 * Matches a string with a regular expression, and returns an array containing the results of that search.
 * @param matcher - `RegExp` a variable name or string literal containing the regular expression pattern and flags
 * @param val - Any `String`
 * @returns The result of `val.match(matcher)`
 *
 * @example
 * ```ts
 * match(/xyz/, 'vwxyz') // ['xyz']
 * ```
 *
 * @beta
 */
declare const match: ((matcher: string | RegExp, val: string) => RegExpMatchArray | null) & ((matcher: string | RegExp) => (val: string) => RegExpMatchArray | null);
/**
 * Returns length property.
 *
 * @param val - Value with length property
 * @returns The result of `val.length`
 *
 * @example
 * ```ts
 * length('hello') // 5
 * length(['hello', 'world', 1]) // 3
 * length({length: 5, text: 'hello'}) // 5
 * ```
 *
 * @beta
 */
declare const length: <T extends {
    length: number;
}>(val: T) => T["length"];
/**
 * whether a given `string` matches a given regular expression.
 *
 * @param regExp - Any Regular expression
 * @param val - Any `string` value
 * @returns The result of `regExp.test(val)`
 *
 * @example
 * ```ts
 * test(new RegExp('^test'), 'testdata') // true
 * test(/xyz$/, 'testxyz') // true
 * ```
 *
 * @category `RegExp`
 *
 * @beta
 */
declare const test: ((regExp: RegExp, val: string) => boolean) & ((regExp: RegExp) => (val: string) => boolean);
/**
 * Executes a search on a `string` using a regular expression pattern, and returns an `array` containing the results of that search.
 * @param regExp - Any `RegExp`
 * @param val - Any `String`
 * @returns The result of `regExp.exec(val)`
 *
 * @example
 * ```ts
 * exec(/^test/, 'test-data') // ['test']
 * ```
 *
 * @beta
 */
declare const exec: ((regExp: RegExp, val: string) => RegExpExecArray | null) & ((regExp: RegExp) => (val: string) => RegExpExecArray | null);
/**
 * Returns a Boolean value indicating the state of the dotAll flag (s) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.dotAll`
 *
 * @example
 * ```ts
 * dotAll(/test/s) // true
 * dotAll(/test/) // false
 * ```
 *
 * @beta
 */
declare const dotAll: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.unicode`
 *
 * @example
 * ```ts
 * dotAll(/test/u) // true
 * dotAll(/test/) // false
 * ```
 *
 * @beta
 */
declare const unicode: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.ignoreCase`
 *
 * @example
 * ```ts
 * ignoreCase(/test/s) // true
 * ignoreCase(/test/) // false
 * ```
 *
 * @beta
 */
declare const ignoreCase: (regExp: RegExp) => boolean;
/**
 * Returns a string indicating the flags of the regular expression in question. This field is read-only. The characters in this string are sequenced and concatenated in the following order:
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.flags`
 *
 * @remarks
 * - "g" for global
 * - "i" for ignoreCase
 * - "m" for multiline
 * - "u" for unicode
 * - "y" for sticky
 *
 * If no flags are set, the value is the empty string.
 *
 * @example
 * ```ts
 * flags(/test/s) // true
 * flags(/test/) // false
 * ```
 *
 * @beta
 */
declare const flags: (regExp: RegExp) => string;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.global`
 *
 * @example
 * ```ts
 * global(/test/g) // true
 * global(/test/) // false
 * ```
 *
 * @beta
 */
declare const global: (regExp: RegExp) => boolean;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.sticky`
 *
 * @example
 * ```ts
 * sticky(/test/y) // true
 * sticky(/test/) // false
 * ```
 *
 * @beta
 */
declare const sticky: (regExp: RegExp) => boolean;
/**
 * Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.multiline`
 *
 * @example
 * ```ts
 * multiline(/test/y) // true
 * multiline(/test/) // false
 * ```
 *
 * @beta
 */
declare const multiline: (regExp: RegExp) => boolean;
/**
 * Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.source`
 *
 * @example
 * ```ts
 * source(/test/s) // true
 * source(/test/) // false
 * ```
 *
 * @beta
 */
declare const source: (regExp: RegExp) => string;
// Copyright 2021-present the Core-fn authors. All rights reserved. MIT license.
/**
 * Returns read/write integer property of `RegExp` instances that specifies the index at which to start the next match.
 * @param regExp - Any `RegExp`
 * @returns The result of `regExp.lastIndex`
 *
 * @example
 * ```ts
 * const re = /t/g;
 * exec(re, "test");
 * lastIndex(re) // 1
 * ```
 *
 * @beta
 */
declare const lastIndex: (regExp: RegExp) => number;
export { replace, startsWith, endsWith, trim, trimLeft, trimRight, toLowerCase, toUpperCase, repeat, trimEnd, trimStart, match, length, test, exec, dotAll, unicode, ignoreCase, flags, global, sticky, multiline, source, lastIndex };
//# sourceMappingURL=index.es.d.ts.map